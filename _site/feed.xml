<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Digital Signal Processing in Radio Astronomy - Lessons Portal</title>
    <description>Lots of lessons</description>
    <link>http://localhost:4000/dspira-lessons/</link>
    <atom:link href="http://localhost:4000/dspira-lessons/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Detailed Instructions for Assembling the CAN</title>
        <description>&lt;p&gt;The CAN is the back end of the horn antenna. The CAN is made up of two parts:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a paint thinner can&lt;/li&gt;
  &lt;li&gt;a feedthrough antenna&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;making-the-feedthrough-antenna&quot;&gt;Making the Feedthrough Antenna&lt;/h2&gt;

&lt;p&gt;The feedthrough antenna is made up of two parts:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a 5.25 cm length of 4 gauge copper wire&lt;/li&gt;
  &lt;li&gt;a panel mount 4 hole male SMA connector&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The two parts are soldered together. The simplest way of doing this is by placing each part horizontally in the clips of the helping hands of your soldering stand. A small drop of solder is melted onto the tip of the SMA connector and onto the tip of copper wire. The two soldered ends are brought together and then soldered together. Make sure that the SMA connector and the copper wire are aligned horizontally before soldering. &lt;strong&gt;Remember that the parts will be hot!&lt;/strong&gt; Do not handle the parts too quickly after applying the solder to the tip of the SMA connector and the copper wire. Use tweezers or needle nose pliers to handle the hot parts. You can also let the parts cool before handling. Click on the video link to watch a demonstration of soldering the SMA connector to the copper wire.&lt;/p&gt;

&lt;p&gt;https://youtu.be/lt63VYeqB38&lt;/p&gt;

&lt;h2 id=&quot;preparing-the-can&quot;&gt;Preparing the Can&lt;/h2&gt;

&lt;p&gt;Making the paint thinner can into the back end of the radio telescope requires four steps:&lt;br /&gt;
     1. Removing the bottom of the paint thinner can
     2. Drilling the hole for the antenna
     3. Taping the spout of the paint thinner can
     4. Attaching the antenna to the paint thinner can&lt;/p&gt;

&lt;h3 id=&quot;removing-the-bottom-of-the-paint-thinner-can&quot;&gt;Removing the Bottom of the Paint Thinner Can&lt;/h3&gt;

&lt;p&gt;Removing the bottom of the paint thinner can is best done with a smooth edge can opener. The OXO Smooth Edge Can Opener model number 2128100 works the best. This can opener cuts on the outside of the can instead of the inside and leaves a very smooth edge. This can opener also has a top turning knob. Do not get a side turning knob can opener. The side turning knob hits the side of the paint thinner can. A regular can opener will also not engage far enough down the inside edge of the paint thinner can to cut properly or at all. The rounded corners of a paint thinner can are also impossible for a regular can opener to navigate. Click on the video link to watch a demonstration of cutting the bottom off the paint thinner can.&lt;/p&gt;

&lt;p&gt;https://youtu.be/IFm9_-f6lvQ&lt;/p&gt;

&lt;h3 id=&quot;drilling-the-feedthrough-hole&quot;&gt;Drilling the Feedthrough Hole&lt;/h3&gt;

&lt;p&gt;A hole needs to be drilled in the paint thinner can for the feedthrough antenna. The hole is 1/4 of an inch in diameter and is located 5.25cm from the edge of the top of the paint thinner can (the uncut side) and 3.25 inches from the side (the centerline of the can). You should also place a snuggly fitting wooden support block in the can under the spot where the hole is to be drilled. This will insure a clean, smooth, and circular hole. Click on the video link to watch a demonstration of drilling the feedthrough hole.&lt;/p&gt;

&lt;p&gt;https://youtu.be/nOl8OJEHZHQ&lt;/p&gt;

&lt;h3 id=&quot;taping-the-spout&quot;&gt;Taping the Spout&lt;/h3&gt;

&lt;p&gt;You should tape the spout opening of the can before attaching the feedthrough antenna. You will need two 2 inches long pieces of aluminum tape to cover the outside and inside of the spout. This is assuming that the roll of aluminum tape is 1.5 inches wide. Do your best to keep the tape smooth and flush with the edges of the spout. Click on the video link to watch a demonstration of taping the spout.&lt;/p&gt;

&lt;p&gt;https://youtu.be/t-MNZw7UhMI&lt;/p&gt;

&lt;h3 id=&quot;attaching-the-feedthrough-antenna&quot;&gt;Attaching the Feedthrough Antenna&lt;/h3&gt;

&lt;p&gt;The feedthrough antenna is soldered onto the paint thinner can. First use the soldering iron or hot air gun to melt enough solder to surround the 1/4 inch hole and also be a pool of solder the size of the base of the SMA connector. Let the solder cool. Drop the feedthrough antenna into the hole  copper wire side down. Look into the paint thinner can and center the feedthrough antenna in the 1/4 inch hole. You do not want the copper wire or solder touching the metal can. Use the hot air gun to heat up the SMA connector, ring of solder, and metal can. When all three pieces are at the correct temperature, the solder will liquify and pull the SMA connector down level with the metal can. This should be  a solid connection between the metal can and the SMA connector. Click on the video link to watch a demonstration of attaching the feedthrough antenna.&lt;/p&gt;

&lt;p&gt;https://youtu.be/dH5D2EP3ODM&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/dspira-lessons/AssemblingtheCAN</link>
        <guid isPermaLink="true">http://localhost:4000/dspira-lessons/AssemblingtheCAN</guid>
      </item>
    
      <item>
        <title>Digital Signal Processsing using GNURadio - Fourier Analysis and Radio Astronomy</title>
        <description>&lt;h1 id=&quot;5-fourier-analysis---expert-mode&quot;&gt;5. Fourier Analysis - Expert Mode!&lt;/h1&gt;

&lt;p&gt;As we observed in the previous labs and theory with their corresponding exercises, Fourier analysis is a very important tool in Signal Processing.&lt;/p&gt;

&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#5-fourier-analysis---expert-mode&quot;&gt;5. Fourier Analysis - Expert Mode!&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#52-iq-signals-or-what-is-up-with-all-the-complex-numbers&quot;&gt;5.1. IQ signals &lt;em&gt;or&lt;/em&gt; What is up with all the Complex Numbers&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#53-fast-fourier-transforms-fft&quot;&gt;5.2. Fast Fourier Transforms (FFT)&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#531-8-point-fast-fourier-transform-optional&quot;&gt;5.2.1. 8 Point Fast Fourier Transform &lt;strong&gt;[OPTIONAL]&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#54-fourier-analysis-in-radio-astronomy-a-spectrometer&quot;&gt;5.3. Fourier Analysis in Radio Astronomy: A Spectrometer&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#55-the-spectrometers-purpose&quot;&gt;5.4. The Spectrometer’s purpose&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#56-the-window-field-in-the-gnuradio-fft-block&quot;&gt;5.5. The Window Field in the gnuradio FFT block&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#57-spectral-leakage--polyphase-filter-bank-pfb&quot;&gt;5.6. Spectral Leakage &amp;amp; Polyphase Filter Bank (PFB)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#58-final-upgrade-pfb-spectrometer&quot;&gt;5.7. Final Upgrade: PFB Spectrometer&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#59-saving-data&quot;&gt;5.8. Saving Data&lt;/a&gt;
              - &lt;a href=&quot;#image-credits&quot;&gt;Image Credits&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;

&lt;h2 id=&quot;51-iq-signals-or-what-is-up-with-all-the-complex-numbers&quot;&gt;5.1. IQ signals &lt;em&gt;or&lt;/em&gt; What is up with all the Complex Numbers&lt;/h2&gt;

&lt;p&gt;If you remember from the &lt;a href=&quot;/dspira-lessons/dsplab-sdr/#21-introduction&quot;&gt;lab 2 introduction&lt;/a&gt; an SDR dongle passes the incoming signal through a mixer where the receiver sets the frequency you observe by setting the “LO” frequency which is mixed (multiplied) with the incoming signal.  The signal is actually mixed with 2 LO’s, one cosine wave and one sine wave.  This is called quadrature sampling, and is done so that it is possible to distinguish a signal that is some frequency(say 2MHz) below the “LO” frequency, or 2MHz above the LO frequency.  With just a single mixing and one measurement, one just cannot distinguish between a signal at those two frequencies.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/05/img/iq.png&quot; alt=&quot;IQ&quot; /&gt;
&lt;a href=&quot;#image-credits&quot;&gt;Credit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/dspira-lessons/iq/&quot;&gt;See this jupyter notebook&lt;/a&gt; for an introduction to the idea.&lt;/p&gt;

&lt;p&gt;Now demonstrate IQ processing in gnuradio.  We can demonstrate this at much lower frequencies as well.  Set the sample-rate to 48kHz.  Create 2 tones(cosine signals), one at 8kHz, one at 12kHz.  Create your LO at 10kHz, one a cosine and one a sine.&lt;/p&gt;

&lt;p&gt;Try using the two signals independently, and added together, this is the overall ‘signal’.
Now multiply this signal by the cosine and the sine “LO’s”.  This now will become your IQ signal.  In gnuradio, this is passed into a “float to complex” block,
where the cosine LO mixed signal is the real, and the sine multiplied is the imaginary.  This can then be passed into a sink.&lt;/p&gt;

&lt;p&gt;Add different sinks along the way, looking at just the cosine (“I”) or sine (“Q”)
multiplied signals.  With just the single incoming tone, demonstrate that you can in fact recover it after mixing.  Do we need a filter?  Where? Add one if needed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;52-fast-fourier-transforms-fft&quot;&gt;5.2. Fast Fourier Transforms (FFT)&lt;/h2&gt;

&lt;p&gt;The Discrete Fourier Transform for N samples is given by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X[k] = \sum_{n=0}^{N-1} x[n] \cdot e^\frac{-2\pi kn}{N}&lt;/script&gt;

&lt;p&gt;Evaluating the DFT’s sums directly involves &lt;script type=&quot;math/tex&quot;&gt;N^2&lt;/script&gt; complex multiplications and N(N−1) complex additions, of which &lt;script type=&quot;math/tex&quot;&gt;O(N)&lt;/script&gt; operations can be saved by eliminating trivial operations such as multiplications by 1. Multiplications are particularly expensive computations.&lt;/p&gt;

&lt;p&gt;Fast Fourier transform algorithms drastically reduce the computational complexity. The radix-2 Cooley–Tukey algorithm is a widely used FFT algorithm.  In comparison to the traditional DFT it can compute the same result with only &lt;script type=&quot;math/tex&quot;&gt;\frac{N}{2}log_2(N)&lt;/script&gt; complex multiplications (again, ignoring simplifications of multiplications by 1 and similar) and &lt;script type=&quot;math/tex&quot;&gt;Nlog_2(N)&lt;/script&gt; complex additions.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.dsplib.org/content/fft_dec_in_freq.html&quot;&gt;Check out this link for a derviation of the Cooley-Tukey Algorithm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;521-8-point-fast-fourier-transform-optional&quot;&gt;5.2.1. 8 Point Fast Fourier Transform &lt;strong&gt;[OPTIONAL]&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;The DFT implemented through a Cooley-Tukey Decimation in frequency FFT algorithm has the flowgraph shown below.
&lt;img src=&quot;images/05/img/fft8p.png&quot; alt=&quot;8pfft&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Use appropriate Constant multiplies and and adders to construct the above in gnuradio ( Where W^{i} = $e^\frac{-2\pi ki}{8})$. Are the outputs the Valid frequency domain results?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;53-fourier-analysis-in-radio-astronomy-a-spectrometer&quot;&gt;5.3. Fourier Analysis in Radio Astronomy: A Spectrometer&lt;/h2&gt;

&lt;p&gt;You now have the tools necessary to create the digital signal processing for a Spectrometer for a radio telescope.  A spectrometer:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Separates the incoming radio signal into individual frequency components (breaks it into individual cosine wave amplitudes and phases at each frequency)&lt;/li&gt;
  &lt;li&gt;Measures the power in each of the cosine waves.&lt;/li&gt;
  &lt;li&gt;Integrates (Averages) to get get a more precise measurement of the power at each frequency.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Use GnuRadio to create the signal processing chain to achieve this. Use an osmocom airspy source.  Use an FFT to separate frequency components.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;54-the-spectrometers-purpose&quot;&gt;5.4. The Spectrometer’s purpose&lt;/h2&gt;

&lt;p&gt;As mentioned above, A spectrometer is used to record and measure the spectral content of signals, such as radio waves received from astronomical sources. Specifically, a spectrometer measures the power spectral density (PSD, measured in units of &lt;script type=&quot;math/tex&quot;&gt;W Hz^{−1}&lt;/script&gt;) of a signal. Analysis of spectral content can reveal details of radio sources, as well as properties of the intervening medium like galactic neutral hydrogen. The Power Spectral Density is given by the Wiener-Kinchin theorem for wide sense stationary signals as:&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;S_{xx}(\nu) = \int^{\infty}_{^-\infty}r_{xx}(\tau) e^{-2\pi i\nu\tau}d\tau&lt;/script&gt;
&lt;script type=&quot;math/tex&quot;&gt;r_{xx}= E[x(t)(x(t-\tau)]&lt;/script&gt;
and in the fourier domain
&lt;script type=&quot;math/tex&quot;&gt;S_{xx}(\nu)=E[|X(\nu)|^2]&lt;/script&gt;
E[] stands for the expected value i.e. the mean&lt;/p&gt;

&lt;p&gt;There are therefore two distinct classes of spectrometers: 1) ones that approximate &lt;script type=&quot;math/tex&quot;&gt;S_{xx} (k)&lt;/script&gt; by first forming the autocorrelation, then taking a Fourier transform and 2) those that first convert into the frequency domain to form X(k) before evaluating &lt;script type=&quot;math/tex&quot;&gt;S_{xx} (k)&lt;/script&gt;. These are Autocorrelation Spectrometers and  Fourier Transform Filter  banks respectively.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/05/img/spectro.png&quot; alt=&quot;the two spectrometers&quot; /&gt;
&lt;a href=&quot;#image-credits&quot;&gt;Credit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The one we made above is a Fourier transform filter bank. A filter bank is simply an array of band-pass filters, designed to split an input signal into multiple components . A spectrometer is referred to as a &lt;em&gt;analysis filterbank&lt;/em&gt; where the output of each filter is squared and averaged.&lt;/p&gt;

&lt;h2 id=&quot;55-the-window-field-in-the-gnuradio-fft-block&quot;&gt;5.5. The Window Field in the gnuradio FFT block&lt;/h2&gt;

&lt;p&gt;The spectrometer we constructed effectively works as a array of band-pass FIR filters. If you recall FIR filters their design involves something called window-functions designed to optimize the filter response. The Discrete Fourier transform as it were uses the rectangular window function across each frequency channel. The response is non-ideal leading to spectral leakage i.e. the signal showing up in neighboring frequency channels. Below is a Demonstration of DFT leakage - a tone at 5.1MHz, sampled at 128MHz, and Fourier-transformed with 64 points, appears to varying levels in all the output frequency bins.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/05/img/specleak.png&quot; alt=&quot;specleak&quot; /&gt;
&lt;a href=&quot;#image-credits&quot;&gt;Credit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This can be improveed by using better windowing functions to properly define the frequency channel. Below are some commonly used windowing functions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/05/img/windows.png&quot; alt=&quot;windows&quot; /&gt;
&lt;a href=&quot;#image-credits&quot;&gt;Credit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note the frequncy response, the main lobe width and the attenuation of the side lobes determine how well defined are the frequency channels. The figures below illustrate the difference. The second plot shows the window response in some frequency bins, the ones with the higher side-lobes as responses of boxcar windows and the the lower side-lobes are of the hann window.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/05/img/fftvshann.png&quot; alt=&quot;fftvshan&quot; /&gt;
&lt;a href=&quot;#image-credits&quot;&gt;Credit&lt;/a&gt;
&lt;img src=&quot;images/05/img/nwvsw.png&quot; alt=&quot;rectvshann&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In your spectrometer flowgraph, change the window field in the FFT block and observe how the response of a tone ( a sinusoud signal ) changes for different windows.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;56-spectral-leakage--polyphase-filter-bank-pfb&quot;&gt;5.6. Spectral Leakage &amp;amp; Polyphase Filter Bank (PFB)&lt;/h2&gt;

&lt;p&gt;Despite the appropriate windowing, spectral leakage persists, moreover there is something called a scalloping loss. Scalloping loss is the loss in energy between frequency bin centers due to the non-flat nature of the single-bin frequency response.&lt;/p&gt;

&lt;p&gt;The polyphase filter bank (PFB) technique is a mechanism for alleviating the aforementioned drawbacks of the straightforward DFT. The PFB produces a flat response across the channel and provides excellent suppression of out-of-band signals, as shown below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/05/img/pfb.png&quot; alt=&quot;pfb&quot; /&gt;
&lt;a href=&quot;#image-credits&quot;&gt;Credit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;“Instead of taking an N-point transform directly, a block of data of size N x P = M is read, and multiplied point-by-point with a window function (in other words, the data is ‘weighted’). As mentioned before, the shape of the window function determines the shape of the single-bin frequency response. Since we wish the single-bin frequency response to resemble a rectangular function as much as possible, we choose its Fourier Transform pair, the sinc function, as our window function. Once the multiplication is done, the block of data is split into P subsets of length N each, and added point-by-point. This array is then passed to a regular DFT routine to get an N-point transform that exhibits less leakage. This method is presented graphically below”&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/05/img/pfb_chart.png&quot; alt=&quot;pfb&quot; /&gt;
&lt;a href=&quot;#image-credits&quot;&gt;Credit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The same process, mathematically:&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;y(n) = \sum_{p=0}^{P-1} x(n + pN) h(n+pN)&lt;/script&gt;
Where, where the sub-filter coefficients &lt;script type=&quot;math/tex&quot;&gt;h(n + pN)&lt;/script&gt; correspond to what are called P-tap ‘polyphase sub-filters’. The N such polyphase sub-filters that make up this operation, together with the following DFT stage, are collectively called a ‘polyphase filter bank’ (‘PFB’). A realization of this filter bank is shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/05/img/pfbrealized.png&quot; alt=&quot;pfbrealized&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;57-final-upgrade-pfb-spectrometer&quot;&gt;5.7. Final Upgrade: PFB Spectrometer&lt;/h2&gt;

&lt;p&gt;Add the polyphase filters to your spectrometer just before taking the FFT. Refer to the diagram above, the dotted squares are simply band-pass FIR filters. Use a hann/hamming window.&lt;/p&gt;

&lt;p&gt;The ployphase filter can be realized by implementing following flowgraph:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/05/img/grcpfb1.png&quot; alt=&quot;pfb&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;constant muliplier&lt;/code&gt; blocks are sections of the filter window as seen the diagram detailing the process above. The filter window is designed by using import block to import &lt;code class=&quot;highlighter-rouge&quot;&gt;numpy&lt;/code&gt; and assigning three constant variables as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sinc_sample_locations
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;sinc
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sinc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sinc_sample_locations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;custom_window
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sinc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hamming&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Now &lt;code class=&quot;highlighter-rouge&quot;&gt;custom_window&lt;/code&gt; are all the window co-efficients/taps you need to do the multiplications, your vector length samples at a time. The constants in the constant  multiplier blocks from the top to bottom are as follows:&lt;/p&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;custom_window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;custom_window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;custom_window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;custom_window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;58-saving-data&quot;&gt;5.8. Saving Data&lt;/h2&gt;

&lt;p&gt;Save the spectrometer data for science! (Use File Sink)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE: Our Low Noise Amplifier (LNA) needs to be powered to actually work. We can configure the airspy dongle by settign bias=1 in the device arguments field of the osmocom source block such as:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/05/img/grcpfb2.png&quot; alt=&quot;airspy bias&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;image-credits&quot;&gt;Image Credits&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;The windows, the two types of spectrometers,fft vs hann resposnse &lt;a href=&quot;https://arxiv.org/pdf/1607.03579.pdf&quot;&gt;https://arxiv.org/pdf/1607.03579.pdf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;The PFB flowgraph, spectral leakage demo, &lt;a href=&quot;https://casper.berkeley.edu/wiki/The_Polyphase_Filter_Bank_Technique&quot;&gt;https://casper.berkeley.edu/wiki/The_Polyphase_Filter_Bank_Technique&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;IQ diagram &lt;a href=&quot;https://www.dsprelated.com/showarticle/192.php&quot;&gt;https://www.dsprelated.com/showarticle/192.php&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://casper.berkeley.edu/wiki/The_Polyphase_Filter_Bank_Technique&quot;&gt;https://casper.berkeley.edu/wiki/The_Polyphase_Filter_Bank_Technique&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 14 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/dspira-lessons/dsplab-fourier2/</link>
        <guid isPermaLink="true">http://localhost:4000/dspira-lessons/dsplab-fourier2/</guid>
      </item>
    
      <item>
        <title>Digital Signal Processsing using GNURadio - Digital Filter</title>
        <description>&lt;h1 id=&quot;4-digital-filters&quot;&gt;4. Digital Filters&lt;/h1&gt;

&lt;p&gt;A filter changes the nature of the signal. A digital filter does so by manipulating a discretized signal.&lt;/p&gt;

&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#4-digital-filters&quot;&gt;4. Digital Filters&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#41-introduction&quot;&gt;4.1. Introduction&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#411-filter-terminology&quot;&gt;4.1.1. Filter Terminology&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#42-moving-average-filter&quot;&gt;4.2. Moving Average Filter&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#421-exercise-1-noise-reduction&quot;&gt;4.2.1. Exercise 1: Noise Reduction&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#43-fir-finite-impulse-response-filters&quot;&gt;4.3. FIR: Finite Impulse Response Filters&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#431-exercise-2-extracting-fundamental-frequencies-from-a-guitarpiano-chord-c-major&quot;&gt;4.3.1. Exercise 2: Extracting Fundamental Frequencies from a Guitar/Piano Chord (C Major)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#432-exercise-3-digital-audio-equalizer&quot;&gt;4.3.2. Exercise 3: Digital Audio Equalizer&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#433-exercise-4-guitar-tuner&quot;&gt;4.3.3. Exercise 4: Guitar Tuner&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#44-iir-infinite-impulse-response-filters&quot;&gt;4.4. IIR: Infinite Impulse Response Filters&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#441-classic-analog-filters&quot;&gt;4.4.1. Classic Analog Filters&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#442-iir-filter-design&quot;&gt;4.4.2. IIR Filter Design&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;

&lt;h2 id=&quot;41-introduction&quot;&gt;4.1. Introduction&lt;/h2&gt;

&lt;p&gt;As we have seen in the previous lab every signal in the time domain has an equivalent representation in the frequency domain by way of the Fourier transform. Information in a signal can be distinctly displayed as a function of the three parameters: time, frequency and phase. Different filters are designed to manipulate the said information in the signal with respect the different parameters.&lt;/p&gt;

&lt;p&gt;Use for example the signal x as a function of time:
&lt;script type=&quot;math/tex&quot;&gt;x(t) = A cos(\omega t + \phi)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;we can then create filter that when the signal passes through it changes the amplitude, to get &lt;script type=&quot;math/tex&quot;&gt;y(t) = B(\omega) x(t)&lt;/script&gt;.  The output will have a different amplitude compared to the input, depending on the frequency.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;411-filter-terminology&quot;&gt;4.1.1. Filter Terminology&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Cut-off Frequency: The frequency around which the signal either passes or stops&lt;/li&gt;
  &lt;li&gt;Low Pass: A filter which allows only frequencies &lt;em&gt;below&lt;/em&gt; the cutoff frequency  to pass&lt;/li&gt;
  &lt;li&gt;High Pass: A filter which allows only frequencies &lt;em&gt;above&lt;/em&gt; the cutoff frequency  to pass&lt;/li&gt;
  &lt;li&gt;Band Pass: A filter which allows only frequencies &lt;em&gt;between&lt;/em&gt; a range of frequencies to pass&lt;/li&gt;
  &lt;li&gt;Band Stop: A filter which allows only frequencies &lt;em&gt;no within&lt;/em&gt; a range of frequencies to pass&lt;/li&gt;
  &lt;li&gt;Pass-Band: The range of frequencies through which the signal passes&lt;/li&gt;
  &lt;li&gt;Stop Band: The range of frequencies through which no signal passes ideally.&lt;/li&gt;
  &lt;li&gt;Ripple: Oscillations from the expected straight line.&lt;/li&gt;
  &lt;li&gt;Roll-off: The region between the end of the pass-band and a stop-band.&lt;/li&gt;
  &lt;li&gt;Finite Impulse Response (FIR) Filter:  A filter which has no feedback (or has feed-back that is carefully accounted for), such that an impulse (delta function or step) will have an output that eventually goes to zero.&lt;/li&gt;
  &lt;li&gt;Infinite Impulse Response (IIR) Filter:  A filter with feedback.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/1.png&quot; alt=&quot;diagram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;42-moving-average-filter&quot;&gt;4.2. Moving Average Filter&lt;/h2&gt;

&lt;p&gt;A moving average filter does exactly what its name suggests. It is a very commonly used filter and very simple in its implementation. It performs optimally in the time domain particularly functioning to reduce random noise. It is mathematically represented as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_{n-point-average} = \frac{x[M]+x[M-1]+ . . . + x[M-(n-1)]}{n} \\
M\ is\ the\ M^{th}\ index&lt;/script&gt;

&lt;p&gt;&lt;em&gt;NOTE: A moving average filter is a simple finite impulse response(FIR) filter. Specifically it is a low-pass filter.  You can also think of this as a convolution.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;421-exercise-1-noise-reduction&quot;&gt;4.2.1. Exercise 1: Noise Reduction&lt;/h3&gt;

&lt;p&gt;Use a sine wave from the &lt;code class=&quot;highlighter-rouge&quot;&gt;signal source&lt;/code&gt; and add noise to it (Discussed in Lab 1). Pass this to a 8-tap moving average filter. The flowgraph should resemble this diagram:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/2.png&quot; alt=&quot;8 point mvngavg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Observe the signal before and after the filtering.
Cascade multiple 8 point average filters (i.e. connect end to start). This will require saving just your filter as a ‘hier block’ with two ‘pad sources’ and two ‘pad sinks’ (why two?).  Once the block is compiled, reload the blocks (refresh button in gnuradio-companion).  There should now be a “GRC Hier Blocks” section with your block named.  How does the signal change adding more and more averaging?&lt;/p&gt;

&lt;p&gt;*Note: There are two options for ‘heir’ block with or without ‘QT GUI’ appending heir. Choose the one without the ‘QT GUI. Male sure you have to disabled blocks in your floegraph *&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;43-fir-finite-impulse-response-filters&quot;&gt;4.3. FIR: Finite Impulse Response Filters&lt;/h2&gt;

&lt;p&gt;“A finite impulse response (FIR) filter is a filter whose impulse response (or response to any finite length input) is of finite duration, because it settles to zero in finite time. This is in contrast to infinite impulse response (IIR) filters, which may have internal feedback and may continue to respond indefinitely (usually decaying).”&lt;sup id=&quot;fnref:source&quot;&gt;&lt;a href=&quot;#fn:source&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The flow diagram of an FIR filter is shown below, &lt;script type=&quot;math/tex&quot;&gt;x[n]\ and\ y[n]&lt;/script&gt; are inputs and outputs respectively. &lt;script type=&quot;math/tex&quot;&gt;z^{-1}&lt;/script&gt; is the unit delay and &lt;script type=&quot;math/tex&quot;&gt;b_n&lt;/script&gt; are the filter coefficients.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/1000px-FIR_Filter.png&quot; alt=&quot;FIR filter wikipedia&quot; /&gt;&lt;/p&gt;

&lt;p&gt;FIR filters are mathematically fast and relatively easier to design and implement digitally.&lt;/p&gt;

&lt;p&gt;We shall design FIR filters using the graphical tool that ships with gnuradio. This tool requires an additional software dependency to work which can be installed by opening a new termina window and entering&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt install python-qwt5-qt4&lt;/code&gt;. Once the dependency is installed, in the taskbar (move mouse to the top of the window) click on &lt;code class=&quot;highlighter-rouge&quot;&gt;tools&lt;/code&gt; and then &lt;code class=&quot;highlighter-rouge&quot;&gt;filter design tool&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/fdt.png&quot; alt=&quot;filterdesign&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We shall design all our filters by graphically using this tool. Theoretically, there are several methods employed to design a filter. The most common used method is by designing a window function.  In the window design method, one first designs an ideal filter which may have an infinite time response (IIR) and then truncates the impulse response by multiplying it with a finite length window function. The result is a finite impulse response filter whose frequency response is modified from that of the IIR filter. Multiplying the infinite impulse by the window function in the time domain results in the frequency response of the IIR being convolved with the Fourier transform of the window function &lt;sup id=&quot;fnref:source:1&quot;&gt;&lt;a href=&quot;#fn:source&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;For us, this GUI does everything behind the scenes. We observe the response of the designed filters in the window and use the necessary taps/filter-coefficients in the FIR block.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/fdtdemo1.png&quot; alt=&quot;filterdesign1&quot; /&gt;
&lt;img src=&quot;images/04/img/fdtdemo.png&quot; alt=&quot;filterdesign2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;GNU Radio has two kinds of FIR filter blocks. A decimating and interpolating FIR filter which reduce(by dividing) and increase(by multiplying) the number of samples of the filtered signal respectively. When we design our filter we simply copy and paste the Filter Taps in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Taps&lt;/code&gt; field of the filter block properties.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;431-exercise-2-extracting-fundamental-frequencies-from-a-guitarpiano-chord-c-major&quot;&gt;4.3.1. Exercise 2: Extracting Fundamental Frequencies from a Guitar/Piano Chord (C Major)&lt;/h3&gt;

&lt;p&gt;A chord is the sound produced by playing three  or more notes together. We can use fourier transform to extract the frequencies that make up those chords. Build a flow-graph that simply uses an &lt;code class=&quot;highlighter-rouge&quot;&gt;audio source&lt;/code&gt;, converts the float output to complex and sends that into a &lt;code class=&quot;highlighter-rouge&quot;&gt;Frequency Sink&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/audiotosink.png&quot; alt=&quot;audio to sink&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once ready, let’s play the C-Major chord. It is the C (= 261.63Hz) , E (= 329.63Hz) and G (= 392Hz). Notice that the frequency spectrum shows more than just the three fundamental frequencies. They show the harmonics of the three frequencies mentioned above! Recall from Fourier series , these harmonics including the fundamental frequencies when added together makes the waveform that forms the music note. The amplitudes of these harmonics for the same note is different for different instruments because the “timbre” i.e. the waveform produced by every instrument is different!&lt;/p&gt;

&lt;p&gt;Now let us extract just the fundamental frequencies by implementing low pass filters to have:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;C-E-G Fundamental Frequency ( use cut-off frequency 456 Hz)&lt;/li&gt;
  &lt;li&gt;C-E Fundamental Frequency ( use cut-off frequency 361 Hz)&lt;/li&gt;
  &lt;li&gt;C Fundamental Frequency ( use cut-off frequency 296 Hz)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The outputs of the filters in the frequency sink should look like this by zooming in:
&lt;img src=&quot;images/04/img/freq.png&quot; alt=&quot;fund. freq&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You may want to save the filtered audio to disk. Look for the the appropriate “sink” block to do so! You can try this with any other chord. Change the filters accordingly. &lt;a href=&quot;https://en.wikipedia.org/wiki/Piano_key_frequencies&quot;&gt;Click here&lt;/a&gt; for the frequency of every key on the piano.&lt;/p&gt;

&lt;p&gt;Fun Fact: Using Fourier transforms and some cool filtering you can transcribe any chords in any any music piece. For example, &lt;a href=&quot;https://www.wired.com/2008/10/how-a-professor/&quot;&gt;deciphering the “mystery” opening chord of the Beatles’ &lt;em&gt;Hard Day’s Night&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;432-exercise-3-digital-audio-equalizer&quot;&gt;4.3.2. Exercise 3: Digital Audio Equalizer&lt;/h3&gt;

&lt;p&gt;Let us try and construct a simple digital equalizer. I shall present the primer for a very simple 3 band equalizer divided into three frequency bands created by three band-pass filters:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Low range: 20Hz – 250Hz&lt;/li&gt;
  &lt;li&gt;Mid-range: 250Hz – 4kHz&lt;/li&gt;
  &lt;li&gt;High-range: 4kHz – 20kHz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Attach this to FM Radio flow-graph before the &lt;code class=&quot;highlighter-rouge&quot;&gt;audio sink&lt;/code&gt;
 The gnuradio flow-graph will follow this diagram:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/4.png&quot; alt=&quot;equalizer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can of course have more than three frequency channels, you can google commonly used frequency divisions in commercial equalizers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: “Ancient” stereos/cassette players and old audio workstations in music studios have analog equalizers designed using analog filters. If you look at the frequency sink of the output of our digital Equalizer you can observe that the filters work &lt;em&gt;really really&lt;/em&gt; well. Digital filters can be very very precisely designed. The roll-off(or transition width) can be as narrow as you want!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;433-exercise-4-guitar-tuner&quot;&gt;4.3.3. Exercise 4: Guitar Tuner&lt;/h3&gt;

&lt;p&gt;Let us be more ambitious and design a Digital Guitar Tuner in GNU Radio. It is rather simple and very similar to the equalizer:  It is a series of band-pass filters &lt;strong&gt;centred&lt;/strong&gt; on the fundamental frequency of the strings. The Fundamental frequencies of the open guitar string in a standard tuning:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;String&lt;/th&gt;
      &lt;th&gt;Frequency&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1 (E)&lt;/td&gt;
      &lt;td&gt;329.63 Hz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2 (B)&lt;/td&gt;
      &lt;td&gt;246.94 Hz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3 (G)&lt;/td&gt;
      &lt;td&gt;196.00 Hz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4 (D)&lt;/td&gt;
      &lt;td&gt;146.83 Hz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5 (A)&lt;/td&gt;
      &lt;td&gt;110.00 Hz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6 (E)&lt;/td&gt;
      &lt;td&gt;82.41 Hz&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The flow-graph should resemble this diagram:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/3.png&quot; alt=&quot;diagram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Choose an appropriate bandwidth. Add frequency and waterfall sinks for each string. What type of window will you use?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;44-iir-infinite-impulse-response-filters&quot;&gt;4.4. IIR: Infinite Impulse Response Filters&lt;/h2&gt;

&lt;p&gt;The flow diagram of an IIR filter is shown below, &lt;script type=&quot;math/tex&quot;&gt;x[n]\ and\ y[n]&lt;/script&gt; are inputs and outputs respectively. &lt;script type=&quot;math/tex&quot;&gt;z^{-1}&lt;/script&gt; is the unit delay and &lt;script type=&quot;math/tex&quot;&gt;b_n&lt;/script&gt; are the feed-forward filter coefficients, and &lt;script type=&quot;math/tex&quot;&gt;a_n&lt;/script&gt; are the feed-back coefficients.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/IIR-filter.png&quot; alt=&quot;IIR-Filter&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;441-classic-analog-filters&quot;&gt;4.4.1. Classic Analog Filters&lt;/h3&gt;

&lt;p&gt;Analog filters built using traditional circuit elements like inductors, resistors, capacitors, transistor, op-amps, etc. have mathematical approximations that allow us to implement them digitally. There are 4 types each excelling in one parameter while under-performing in another:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Butterworth&lt;/em&gt;: Flattest pass-band but a poor roll-off rate.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Chebyshev&lt;/em&gt;: Some pass-band ripple but a better (steeper) roll-off rate. Chebyshev filters where the ripple is only allowed in the pass-band are called type 1 filters. Chebyshev filters that have ripple only in the stop-band are called type 2 filters , but are are seldom used. Chebyshev filters have a poor phase response.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Elliptic&lt;/em&gt;: Some pass- and stop-band ripple but with the steepest roll-off rate.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/Filters_order5.svg.png&quot; alt=&quot;Filters_order5.svg.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Bessel&lt;/em&gt;: Worst roll-off rate of all four filters but the best phase response.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;images/04/img/bessel.png&quot; alt=&quot;Bessel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;IIR or Infinite response filters are the closest digital implementations of these filters.&lt;/p&gt;

&lt;h3 id=&quot;442-iir-filter-design&quot;&gt;4.4.2. IIR Filter Design&lt;/h3&gt;

&lt;p&gt;Now create an IIR filter to again pull out the fundamental frequency of the C-chord.  Do this again using the ‘Filter design tool’.  When you use an IIR filter, the design is now in ‘normalized’ units of ‘cycles/sample’. To get units of frequency, you must multiply by the sample rate/2 (fs/2) you are using.  So with a sample rate of 48000, you divide the frequency you want by 24000.  For an IIR filter you can use the “IIR Filter” block, where the feed-forward taps are the “b’s” and the feed-back taps are the “a’s”.  Be sure to also select the ‘new’ style of taps.  How many coefficients (taps) are required for an IIR filter in comparison to an FIR filter with a similar response function?  More? Less?  Why?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt; … &lt;a href=&quot;../05&quot;&gt;Next Lab&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:source&quot;&gt;
      &lt;p&gt;https://en.wikipedia.org/wiki/Finite_impulse_response#Window_design_method &lt;a href=&quot;#fnref:source&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:source:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 14 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/dspira-lessons/dsplab-filters/</link>
        <guid isPermaLink="true">http://localhost:4000/dspira-lessons/dsplab-filters/</guid>
      </item>
    
      <item>
        <title>Digital Signal Processsing using GNURadio - Fourier Analysis</title>
        <description>&lt;h1 id=&quot;1-fourier-analysis&quot;&gt;1. Fourier Analysis&lt;/h1&gt;

&lt;p&gt;Fourier Analysis is a very powerful tool that comes into play when we discuss periodic signals. Colloquially, a periodic signal repeats.&lt;/p&gt;

&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-fourier-analysis&quot;&gt;1. Fourier Analysis&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#31-introduction&quot;&gt;3.1. Introduction&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#32-fourier-series&quot;&gt;3.2. Fourier Series&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#321-a-sqaure-wave&quot;&gt;3.2.1. A Sqaure Wave&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#322-a-triangle-wave&quot;&gt;3.2.2. A Triangle Wave&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#323-a-sawtooth-wave&quot;&gt;3.2.3. A Sawtooth wave.&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#33-fourier-series-and-fourier-transforms&quot;&gt;3.3. Fourier Series and Fourier Transforms&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#331-fourier-transform&quot;&gt;3.3.1. Fourier Transform&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#332-example&quot;&gt;3.3.2. Example&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#34-fourier-transform-pairs&quot;&gt;3.4. Fourier Transform Pairs&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;

&lt;h2 id=&quot;31-introduction&quot;&gt;3.1. Introduction&lt;/h2&gt;

&lt;p&gt;Mathematically a signal &lt;script type=&quot;math/tex&quot;&gt;x(t)&lt;/script&gt; is periodic if there exists a positive constant &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; such that:
&lt;script type=&quot;math/tex&quot;&gt;x(t) = x(t + T)&lt;/script&gt;
for all values of &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;. The smallest value of &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; for which this is true is called the fundamental period and is denoted &lt;script type=&quot;math/tex&quot;&gt;T_o&lt;/script&gt;. The corresponding &lt;em&gt;fundamental frequency&lt;/em&gt; is &lt;script type=&quot;math/tex&quot;&gt;f_o = \frac{1}{T_o}&lt;/script&gt;. If &lt;script type=&quot;math/tex&quot;&gt;T_o&lt;/script&gt; is in seconds, then &lt;script type=&quot;math/tex&quot;&gt;f_o&lt;/script&gt; is in Hertz (Hz). The fundamental angular frequency is &lt;script type=&quot;math/tex&quot;&gt;\omega_o = 2\pi f_o&lt;/script&gt; and is measured in rad/sec.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;32-fourier-series&quot;&gt;3.2. Fourier Series&lt;/h2&gt;

&lt;p&gt;A Fourier series is an expansion of a periodic function f(x) in terms of an infinite sum of sines and cosines. The computation and study of Fourier series is known as harmonic analysis and is extremely useful as a way to break up an arbitrary periodic function into a set of simple terms that can be plugged in, solved individually, and then recombined to obtain the solution to the original problem or an approximation to it to whatever accuracy is desired or practical. &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Mathematically in a simple sense an arbitrary function &lt;script type=&quot;math/tex&quot;&gt;f(t)&lt;/script&gt; can be decomposed as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x) = a_0 + \sum_{n=1}^{\infty} a_n cos(nx) + b_n sin(nx)&lt;/script&gt;

&lt;p&gt;We shall explore this concept by making two waveforms using sinosoids:&lt;/p&gt;

&lt;h3 id=&quot;321-a-sqaure-wave&quot;&gt;3.2.1. A Sqaure Wave&lt;/h3&gt;

&lt;p&gt;From &lt;a href=&quot;../01/&quot;&gt;Lab 1&lt;/a&gt;, we have the function generator. We use that to make a square wave of amplitude = 1.&lt;/p&gt;

&lt;p&gt;Mathematically it can be written as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
f(x) = 
  \begin{cases} 
   0 &amp; \text{if } -\pi \leq x \lt 0 \\
   1       &amp; \text{if } 0 \leq x \lt \pi
  \end{cases}\ and\ f(x+2\pi)=f(x) %]]&gt;&lt;/script&gt;

&lt;p&gt;Which has a period of &lt;script type=&quot;math/tex&quot;&gt;2\pi&lt;/script&gt;.  For an arbitrary period P:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
f(x) = 
  \begin{cases} 
   0 &amp; \text{if } -P/2 \leq x \lt 0 \\
   1       &amp; \text{if } 0 \leq x \lt P/2
  \end{cases}\ and\ f(x+P)=f(x) %]]&gt;&lt;/script&gt;

&lt;p&gt;The corresponding Fourier series of the square wave with period &lt;script type=&quot;math/tex&quot;&gt;2\pi&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x) = \frac{1}{2} + \sum_{n=1}^{\infty} \frac{2}{(2k-1)\pi} sin[(2k-1)x] \\
\ \ \ = \frac{1}{2} + \frac{2}{\pi}sin(x) + \frac{2}{3\pi}sin(3x) + \frac{2}{5\pi}sin(5x) + \frac{2}{7\pi}sin(7x) + ... + + \frac{2}{n\pi}sin(nx)\ (\ n\ is\ odd)&lt;/script&gt;

&lt;p&gt;and for arbirary period P:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x) = \frac{1}{2} + \sum_{n=1}^{\infty} \frac{2}{(2k-1)\pi} sin[\frac{2\pi}{P}(2k-1)x] \\
\ \ \ = \frac{1}{2} + \frac{2}{\pi}sin(\frac{2\pi}{P}x) + \frac{2}{3\pi}sin(\frac{2\pi}{P}3x) + \frac{2}{5\pi}sin(\frac{2\pi}{P}5x) + \frac{2}{7\pi}sin(\frac{2\pi}{P}7x) + ... + + \frac{2}{n\pi}sin(\frac{2\pi}{P}nx)\ (\ n\ is\ odd)&lt;/script&gt;

&lt;p&gt;Use more and more sources to add additional sinusoids and see what waveform you get after each added term.  How many terms until you’re square wave looks good?  5?  10?&lt;/p&gt;

&lt;p&gt;It should look similar to this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/03/img/1.png&quot; alt=&quot;square wave&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This type of analysis is important for digital design in the sense that most digital signals are square waves, representing either a 1 or a zero.  So if your signal is at 10MHz, how fast should the electronics and design work?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;322-a-triangle-wave&quot;&gt;3.2.2. A Triangle Wave&lt;/h3&gt;

&lt;p&gt;The triangular wave is defined as:
&lt;script type=&quot;math/tex&quot;&gt;f(x)=|x|\  for\ -1\lt x \leq 1\ and\ f(x+2)=f(x)\ for\ all\ x&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Its corresponding fourier series is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x) = \frac{1}{2} - \sum_{n=1}^{\infty} \frac{4}{(2k-1)^2\pi^2} cos[(2k-1)\pi x] \\
= \frac{1}{2} - \frac{4}{\pi^2}cos(\pi x) - \frac{4}{9\pi^2}cos(3 \pi x) - \frac{4}{25\pi^2}cos(5\pi x) - ...&lt;/script&gt;

&lt;p&gt;Make a flowgraph out of the expanded terms above and check the output after each operation. Do you need more or fewer components to begin looking like a triangle wave as compared to a square wave?  Why do you think that is?&lt;/p&gt;

&lt;p&gt;It should give an output like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/03/img/2.png&quot; alt=&quot;Triangle wave&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;323-a-sawtooth-wave&quot;&gt;3.2.3. A Sawtooth wave.&lt;/h3&gt;

&lt;p&gt;Now mathematically define a sawtooth wave and find it’s Fourier series expansion.  Then create its flow-graph, again with more and more Fourier components.  Again, do you need more/less Fourier components as compared to a square or triangle wave?&lt;/p&gt;

&lt;h2 id=&quot;33-fourier-series-and-fourier-transforms&quot;&gt;3.3. Fourier Series and Fourier Transforms&lt;/h2&gt;

&lt;p&gt;We segue into the concept of Fourier transforms directly by seeing how they relate to fourier series. First some mathematics to associate familiarity, the Fourier transform of &lt;script type=&quot;math/tex&quot;&gt;x(t)&lt;/script&gt; is given by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X(\omega) = \int_{-\infty}^{+\infty} x(t) cos(\omega t)dt -i \int_{-\infty}^{+\infty} x(t) sin(\omega t) = \int_{-\infty}^{+\infty}x(t)e^{-i\omega t}dt&lt;/script&gt;

&lt;p&gt;When x(t) is periodic and has a Fourier series expansion, this integral is pulling out those sines and cosines in the expansion.&lt;/p&gt;

&lt;p&gt;In more detail: For the complex representation of a Fourier series of a periodic function &lt;script type=&quot;math/tex&quot;&gt;x(t)&lt;/script&gt; :&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x(t) = \sum_{-\infty}^{\infty} c_n e^{jn\omega t}&lt;/script&gt;

&lt;p&gt;The co-effecients, &lt;script type=&quot;math/tex&quot;&gt;c_n&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;x(t)&lt;/script&gt; (which  has the period &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; is given by the relation:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;c_n = \frac{1}{T} X(n\omega_o)&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;X(\omega)&lt;/script&gt; is the Fourier transform and &lt;script type=&quot;math/tex&quot;&gt;\omega_o = \frac{2\pi}{T}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In summary, the Fourier series of a signal is a sum of sines and cosines. And, the Fourier transform decomposes the signal into it’s its frequency components with their relative strength. This can be visually seen in a neat animation as shown below ( &lt;em&gt;credit: wikipedia&lt;/em&gt; ) and in the next section&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/03/img/Fourier_series_and_transform.gif&quot; alt=&quot;animation FS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;331-fourier-transform&quot;&gt;3.3.1. Fourier Transform&lt;/h3&gt;

&lt;p&gt;Use the &lt;a href=&quot;../03/#321-a-sqaure-wave&quot;&gt;Square Wave&lt;/a&gt; and the &lt;a href=&quot;../03/#322-a-triangle-wave&quot;&gt;Triangle Wave&lt;/a&gt; flowgraphs from the previous exercise.&lt;/p&gt;

&lt;p&gt;First use a &lt;code class=&quot;highlighter-rouge&quot;&gt;signal source&lt;/code&gt; block to make a square wave and feed the signal into a &lt;code class=&quot;highlighter-rouge&quot;&gt;QT frequency sink&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Frequency Sink takes the Fourier Transform of the incoming signal and plots the output of the fourier transform&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Place another &lt;code class=&quot;highlighter-rouge&quot;&gt;QT Frequency Sink&lt;/code&gt; and change the number of inputs to the number of Fourier series sinusoids you have in your flowgraph and feed all the sinusoids (vis-a-vis the individual Fourier series terms) into the frequency sink&lt;/p&gt;

&lt;p&gt;The output looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/03/img/3.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The colored peaks are the Fourier transforms of the individual sinusoids. Do they align with the Fourier Transform of the pure square wave? If you add more terms of the Fourier series to the sink, how do they compare?&lt;/p&gt;

&lt;p&gt;Repeat this exercise for the triangle wave.&lt;/p&gt;

&lt;p&gt;We’ve been taking Fourier transform of the signal every time we see a plot with frequency in the time axes.&lt;/p&gt;

&lt;p&gt;We shall visit Fourier transforms in detail again that in Lab 5.&lt;/p&gt;

&lt;h3 id=&quot;332-example&quot;&gt;3.3.2. Example&lt;/h3&gt;

&lt;p&gt;We can also think of this to use gnuradio-companion to graphically get the Fourier components of a signal using a Fourier transform.  Create a flow-graph with a signal source-&amp;gt;FFT(Fourier transform)-&amp;gt; complex to real/imag -&amp;gt; vector sinks.  The output of the real-part contains the cosine components of the transform.  The imaginary part contains the sine components of the Fourier expansion.&lt;/p&gt;

&lt;p&gt;It is also helpful to plot the time series to see what your input is and the frequency sink to make it easier to just read off the frequency of the components.&lt;/p&gt;

&lt;p&gt;An example flowgraph looks like:
&lt;img src=&quot;images/03/img/4.png&quot; alt=&quot;sawtooth&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The FFT block is a special block which does the Fourier transform really fast. Play around with the FFT block and your general waveform generator from Lab 1 to take their Fourier transform.  Use this to read off the Fourier series coefficients.  This can still be used with a periodic signal with much less obvious structure.&lt;/p&gt;

&lt;h2 id=&quot;34-fourier-transform-pairs&quot;&gt;3.4. Fourier Transform Pairs&lt;/h2&gt;

&lt;p&gt;Let us revisit Fourier transform by exploring the concept through their various properties. Refer to this &lt;a href=&quot;http://www.ws.binghamton.edu/fowler/fowler%20personal%20page/EE301_files/FT%20Tables_rev3.pdf&quot;&gt;Table of Fourier Transform Pairs and Properties&lt;/a&gt; and implement in gnuradio the following :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Fourier Transform a Sinusoid and&lt;/li&gt;
  &lt;li&gt;Fourier transform of the sinusoid delayed by one sample&lt;/li&gt;
  &lt;li&gt;The output of the Fourier transform of a constant source of the value 1 is a dirac delta function. Find the FT of the dirac delta function and the dirac delta function time delayed.&lt;/li&gt;
  &lt;li&gt;Fourier transform of &lt;script type=&quot;math/tex&quot;&gt;e^{j\omega_o t}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;Demonstrate the convolution property (use square wave) &lt;em&gt;Hint: Inverse Fourier transform can be implemented by choosing &lt;code class=&quot;highlighter-rouge&quot;&gt;reverse&lt;/code&gt; in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Forward/Reverse&lt;/code&gt; Option. Hint: The output should be a triangle wave&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Fourier transform  a square pulse of different widths (i.e. tau &lt;em&gt;refer lab 1.3.1&lt;/em&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Try to implement other properties from the link of fourier transform pairs and properties as well.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE: Use the &lt;code class=&quot;highlighter-rouge&quot;&gt;FFT&lt;/code&gt; Block for the above exercises. Use complex sources. The &lt;code class=&quot;highlighter-rouge&quot;&gt;FFT&lt;/code&gt; block takes an input vector and outputs a complex vector. Use to appropriate stream to vector and complex to real/imaginary convertor blocks where necessary&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The power of the FFT output is given by multiplying the complex output of the FFT by its complex conjugate&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use vector sinks for signals that ‘vectors’ i.e. data comes out in chunks of a particular matrix size(vector length)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt; ……&lt;a href=&quot;../04&quot;&gt;Next Lab&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;http://mathworld.wolfram.com/FourierSeries.html &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 14 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/dspira-lessons/dsplab-fourier1/</link>
        <guid isPermaLink="true">http://localhost:4000/dspira-lessons/dsplab-fourier1/</guid>
      </item>
    
      <item>
        <title>Digital Signal Processsing using GNURadio - Software Defined Radio</title>
        <description>&lt;h1 id=&quot;2-software-defined-radio---hardware&quot;&gt;2. Software Defined Radio - Hardware&lt;/h1&gt;

&lt;p&gt;In &lt;a href=&quot;../01/&quot;&gt;Lab 1&lt;/a&gt; we learned how to work around GNU Radio Companion (GRC) and simulate signals and instruments. We shall now step into the real world with real signals.&lt;/p&gt;

&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#2-software-defined-radio---hardware&quot;&gt;2. Software Defined Radio - Hardware&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#21-introduction&quot;&gt;2.1. Introduction&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#22-frequency-correction-of-the-sdr-dongle&quot;&gt;2.2 Frequency Correction of the SDR Dongle&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#23-gnuradio-fm&quot;&gt;2.3. GNURadio FM&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#231--signal-modulation&quot;&gt;2.3.1  Signal Modulation&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#2311-amplitude-modulation&quot;&gt;2.3.1.1 Amplitude Modulation&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#2312-frequency-modulation&quot;&gt;2.3.1.2 Frequency Modulation&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#232-lets-make-our-fm-radio&quot;&gt;2.3.2 Let’s Make our FM Radio&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#24-fun-sdrgnu-radio-things&quot;&gt;2.4. Fun SDR/GNU Radio things&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;

&lt;h2 id=&quot;21-introduction&quot;&gt;2.1. Introduction&lt;/h2&gt;

&lt;p&gt;A “simplified” diagram of the device which we shall be using is shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/02/img/1.png&quot; alt=&quot;AIRSPY&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Simplifying this further for a general SDR hardware including the energy conversions:&lt;/p&gt;

&lt;p&gt;(EM Waves)))) &amp;gt;-(Antenna)–&amp;gt;(Amplifier)—&amp;gt;(Local Oscillators + Filters)–&amp;gt;(Analog to Digital Convertor)–&amp;gt;(networking control: usually USB)—&amp;gt;[Computer]&lt;/p&gt;

&lt;p&gt;Radio Waves excite electrons in the antenna and induces a current. The frequencies the antenna is most sensitive to is determined by the geometry of the antenna’s design. The electric current is then initially amplified a bit. This amplifier is generally a “Low Noise Amplifier” because we want as little as possible in the antenna signal from the local electronics. Processing a signal at a fixed frequency gives a radio receiver improved performance so thus a local oscillator (LO) is used. It is an electronic oscillator used with a mixer to change the frequency of a signal. This frequency conversion process, also called heterodyning, produces the sum and difference frequencies from the frequency of the local oscillator and frequency of the input signal. The desired frequency is then filtered out and if required amplified again. The last step is the most crucial step where-in the signal is digitized to be sent to the computer to be manipulated by our gnuradio code!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;22-frequency-correction-of-the-sdr-dongle&quot;&gt;2.2 Frequency Correction of the SDR Dongle&lt;/h2&gt;

&lt;p&gt;The hardware is well made, but a precision clock is quite expensive. The frequency the “tuner” tunes to may be slightly off from the actual frequency it is tuning to. We can correct for that in the software.  For high-end SDR dongles this correction is virtually non existent but some low-end dongles have higher deviations!&lt;/p&gt;

&lt;p&gt;We can transmit a signal using a known and reliable tone. Then we use our receiver set up with gqrx to see the signal. If the incoming signal is exactly at the expected frequency then the intenral clock is working well. If not we look at the &lt;code class=&quot;highlighter-rouge&quot;&gt;input controls&lt;/code&gt; tab in gqrx and change the &lt;code class=&quot;highlighter-rouge&quot;&gt;freq. correction&lt;/code&gt; value until the peak is at the correct output.
 This value will be different for all dongles.  It also changes with the temperature of the dongle.  It is interesting to watch this change as the dongle warms up. Note your value for future purposes.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;23-gnuradio-fm&quot;&gt;2.3. GNURadio FM&lt;/h2&gt;

&lt;p&gt;We used gqrx in section 1.2 to listen to FM now we shall code our own radio using GRC!&lt;/p&gt;

&lt;h3 id=&quot;231--signal-modulation&quot;&gt;2.3.1  Signal Modulation&lt;/h3&gt;

&lt;p&gt;Modulation is a process of mixing a signal with a sinusoid to produce a new signal. Consider a signal represented by the function:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(t) = A \sin(\omega t + \phi).&lt;/script&gt;

&lt;p&gt;This sinusoid has 3 variables that can be altered ti change the function f(t). The first term, A, is called the magnitude, or amplitude of the sinusoid. The next term, &lt;script type=&quot;math/tex&quot;&gt;\omega&lt;/script&gt; is known as the frequency, and the last term, &lt;script type=&quot;math/tex&quot;&gt;\phi&lt;/script&gt; is known as the phase angle. We can encode our message in either of these three parameters.&lt;/p&gt;

&lt;p&gt;The sinusoidal signal that is used in the modulation is known as the carrier signal, or simply “the carrier”. The signal that is used in modulating the carrier signal (or sinusoidal signal) is known as the “data signal” or the “message signal”.&lt;/p&gt;

&lt;p&gt;In other words we can say that modulation is used because some data signals are not always suitable for direct transmission, but the modulated signal may be more suitable.&lt;/p&gt;

&lt;p&gt;It follows  from above we encode in the above three variables. Consequently, we have 3 basic types of analog modulation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Amplitude Modulation&lt;/li&gt;
  &lt;li&gt;Frequency Modulation&lt;/li&gt;
  &lt;li&gt;Phase Modulation&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2311-amplitude-modulation&quot;&gt;2.3.1.1 Amplitude Modulation&lt;/h4&gt;

&lt;p&gt;For our discussion of amplitide modulation consider a carrier wave of frequency &lt;script type=&quot;math/tex&quot;&gt;f_c&lt;/script&gt; and amplitude &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; given by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;c(t) = A \cdot \sin(2 \pi f_c t).&lt;/script&gt;

&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;m(t)&lt;/script&gt; represent the modulation waveform. For this example we shall take the modulation to be simply a sine wave of a frequency &lt;script type=&quot;math/tex&quot;&gt;f_m&lt;/script&gt;, a much lower frequency (such as an audio frequency) than &lt;script type=&quot;math/tex&quot;&gt;f_c&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;m(t) = M\cdot \cos(2 \pi f_m t + \phi),&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is the amplitude of the modulation. If &lt;script type=&quot;math/tex&quot;&gt;M&gt;1&lt;/script&gt; then overmodulation occurs and reconstruction of message signal from the transmitted signal is more difficult. Amplitude modulation results when the carrier &lt;script type=&quot;math/tex&quot;&gt;c(t)&lt;/script&gt; is multiplied by the positive quantity  &lt;script type=&quot;math/tex&quot;&gt;(1+m(t))&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y(t) = [1 + m(t)]\cdot c(t) \\
\ \ = [1 + M\cdot \cos(2 \pi f_m t + \phi)] \cdot A \cdot \sin(2 \pi f_c t)&lt;/script&gt;

&lt;p&gt;Using trigonometric identities, &lt;script type=&quot;math/tex&quot;&gt;y(t)&lt;/script&gt; can be shown to be the sum of three sine waves:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y(t) = A \cdot \sin(2 \pi f_c t) + \frac{AM}{2} \left[\sin(2 \pi (f_c + f_m) t + \phi) + \sin(2 \pi (f_c - f_m) t - \phi)\right]&lt;/script&gt;

&lt;p&gt;Therefore, the modulated signal has three components: the carrier wave &lt;script type=&quot;math/tex&quot;&gt;c(t)&lt;/script&gt; which is unchanged, and two pure sine waves (known as sidebands) with frequencies slightly above and below the carrier frequency &lt;script type=&quot;math/tex&quot;&gt;f_c&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Demodulation or extracting the message from the carrier involves simply filtering out the carrier signal. We can construct an AM radio receiver on GNU radio however our SDR dongle can only tune from ~20 MHz to ~1800 MHz.&lt;/p&gt;

&lt;h4 id=&quot;2312-frequency-modulation&quot;&gt;2.3.1.2 Frequency Modulation&lt;/h4&gt;

&lt;p&gt;As the name suggests the message signal is encoded in the frequency variable of the carrier signal as in &lt;script type=&quot;math/tex&quot;&gt;x(t) = a \sin (f(t)t + \phi)&lt;/script&gt;. If the information to be transmitted (i.e., the data/message signal is &lt;script type=&quot;math/tex&quot;&gt;x_m(t)&lt;/script&gt; and the sinusoidal carrier is &lt;script type=&quot;math/tex&quot;&gt;x_c(t) = A_c \cos (2 \pi f_c t)&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;f_c&lt;/script&gt; is the carrier’s base frequency, and &lt;script type=&quot;math/tex&quot;&gt;A_c&lt;/script&gt; is the carrier’s amplitude, the modulator combines the carrier with the data/message signal to get the transmitted signal&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align} 
y(t) &amp; = A_c \cos \left( 2 \pi f(t) t \right) \\ 
     &amp; = A_{c} \cos \left( 2 \pi \left[ f_{c} + f_{\Delta} x_{m}(t) \right] t\right)\\ 
     &amp; = A_{c} \cos \left( 2 \pi f_{c} t + 2 \pi f_{\Delta} x_{m}(t) t \right) \\ 
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;where $$f_{\Delta} is the sensitivity of the frequency modulator which adjusts how much bandwidth is used for the signal.&lt;/p&gt;

&lt;h3 id=&quot;232-lets-make-our-fm-radio&quot;&gt;2.3.2 Let’s Make our FM Radio&lt;/h3&gt;

&lt;p&gt;One way to demodulate the signal is to extract the message encoded in the frequency of the sinusoid outside the sinusoid. That can be achieved by “fast” differentiating the sine wave, treating the message as a constant. Consider the following:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x(t) = a \sin (f(t)t + \phi) \\
\frac{d x(t)}{dt} = af(t) \cos(f(t)t + \phi) \\
\ \ \  = A(t) \cos(f(t) + \phi)&lt;/script&gt;

&lt;p&gt;For the FM signal&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y(t) = A_c \cos \left( 2 \pi f_c t + 2 \pi f_{\Delta} x_{m} (t) t  \right) \\
 \ \ \  = A_c cos ( \theta(t) )&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align} 
y'(t) &amp; = -A_c \theta ' (t) \sin(\theta (t) ) \\
    &amp; = -2 \pi A_c ( f_c + f_{\Delta} x_m(t) ) \sin (\theta (t))
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;We observe that we converted the FM signal into the form &lt;script type=&quot;math/tex&quot;&gt;y(t) = [1 + m(t)]\cdot c(t)&lt;/script&gt; which is an AM signal. We can easily demodulate this AM signal by filtering out the AM “carrier”. It follows the following flow:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;FM —-&amp;gt;&lt;/td&gt;
      &lt;td&gt;Differentiator&lt;/td&gt;
      &lt;td&gt;—-&amp;gt;&lt;/td&gt;
      &lt;td&gt;Envelope Detector&lt;/td&gt;
      &lt;td&gt;—-&amp;gt; Signal&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;A similar operation can be achieved in GNU radio using the following flow:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;FM —&amp;gt;&lt;/td&gt;
      &lt;td&gt;Filter out the signal of interest&lt;/td&gt;
      &lt;td&gt;—&amp;gt;&lt;/td&gt;
      &lt;td&gt;Resample Signal&lt;/td&gt;
      &lt;td&gt;—&amp;gt;&lt;/td&gt;
      &lt;td&gt;Quadrature Demodulator&lt;/td&gt;
      &lt;td&gt;—&amp;gt;&lt;/td&gt;
      &lt;td&gt;Lowpass Filter&lt;/td&gt;
      &lt;td&gt;—&amp;gt; Audio Signal&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The quadrature demodulator uses a different technique than differentiating the signal since the incoming data is complex, but the end result is the same, where the output is proportional to the change in frequency of the input. (That gnuradio block actually has a good explanation of the math in the description. )&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hints:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Source&lt;/strong&gt;: Since we are using a hardware source we have to use the appropriate block. Search for the &lt;code class=&quot;highlighter-rouge&quot;&gt;osmocom Source&lt;/code&gt; block. The Device arguments should be &lt;code class=&quot;highlighter-rouge&quot;&gt;airspy=0&lt;/code&gt;. &lt;strong&gt;NOTE: The Sample rate supported by this dongle is either 2.5 MHz or 10 MHz. We shall set our &lt;code class=&quot;highlighter-rouge&quot;&gt;samp_freq&lt;/code&gt; variable to &lt;code class=&quot;highlighter-rouge&quot;&gt;2500000&lt;/code&gt;&lt;/strong&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Ch0: Frequency (Hz)&lt;/code&gt; is the frequency you want to tune to.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/02/img/7.png&quot; alt=&quot;source&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Low Pass Filter&lt;/strong&gt;: This filters out all the frequencies apart from the one we want to tune our radio to. Note that I have another variable called &lt;code class=&quot;highlighter-rouge&quot;&gt;channel_width&lt;/code&gt; which is equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;200e3&lt;/code&gt;. It is to filter out at a data rate 200kHz.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/02/img/7_1.png&quot; alt=&quot;LP Filter&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resampling Signal&lt;/strong&gt;: Use the ‘Rational Resampler’ block. Resample the signal such that the frequency of the signal is a multiple of out output frequency. The output frequency ( ‘out_rate’) is the frequency at which the sound card accepts samples i.e. 48 kHz to play audio. The output frequency should still be near to the bandwhith of the message i.e. 200kHz. 192kHz ie ‘out_rate’ is the closest multiple of 48kHz to it. As noticed on the screen shot here is a new variable ‘decimation == int(samp_rate/(2*channel_width))’&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/02/img/7_2.png&quot; alt=&quot;resample&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quadrature demodulation&lt;/strong&gt;: This block extracts the time dependend frequency component of the signal which is the audio signal.Use the quad demod block and fill in ‘(out_rate/(2&lt;em&gt;math.pi&lt;/em&gt;channel_width))’ in the gain field&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/02/img/7_4.png&quot; alt=&quot;quaddemod&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lowpass Filter&lt;/strong&gt;: Use a lowpass filter with the cutoff frequency at 18 kHz ( because human audio perfecption has an upper limit close to it). Enter the decimation value to downsample the signal coming in from 192kHz to 48kHz the rate at which the sound card works.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/02/img/7_3.png&quot; alt=&quot;lp2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Play audio from an audio sink&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Lets capture some sweet tunes!&lt;/p&gt;

&lt;!--
Our FM Radio design GRC in its most basic has the following flow:

[Source]--(Low Pass Filter)---(Resampler)--(FM demodulator)---(Volume Gain)---[Audio Sink]

Find the corresponding blocks and connect them according to the flow given above. Use appropraite variables and GUI elements. USe the QT GUI Sink to visually show the signal in the flow before and after modulation. 

*Hints for reference*

**Source**: Since we are using a hardware source we have to use the appropriate block. Search for the ``osmocom Source`` block. The Device arguments should be ``airspy=0``. **NOTE: The Sample rate supported by this dongle is either 2.5 MHz or 10 MHz. We shall set our ``samp_freq`` variable to ``2500000``**. The ``Ch0: Frequency (Hz)`` is the frequency you want to tune to. 

![source](images/02/img/7.png)

**Low Pass Filter**: This filters out all the frequencies apart from the one we want to tune our radio to. Note that I have another variable called ``channel_width`` which is equal to ``200e3``. It is to filter out at a data rate 200kHz. 

![LP Filter](images/02/img/7_1.png)

**Resampler**: We are attempting to change the data rate to 480kHz which is 10 times (a nice multiple of) the soundcard's working frequency for all audio data files, and will still contain all the information left after we filtered to 200kHz. We do this because the sample rate is 2.5MHz and 480kHZ is not divisor of it i.e. they aren't integral multiples ( 2.5MHz/480kHz = 5.208).  Continuing the resampling we started earlier. we 'decimate' the input by dividing ``5`` and 'interpolate' it by mulitplying by ``12`` to resample to 480kHz!

![resampler](images/02/img/8.png)

**FM demodulator**: This is the most important part of the radio, well, it is essentially the radio as it decodes the signals to audio!

![demod](images/02/img/9.png)

**Volume Gain**: Raise the roof people! It's a simple multiply constant block.

**Audio Sink**: To listen to the sweet tunes!

The choices made so far here may seem a bit arbitrary.  In the future we'll go into filters and filter design, and you can return to your FM radio, and possibly improve it!
--&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;24-fun-sdrgnu-radio-things&quot;&gt;2.4. Fun SDR/GNU Radio things&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;AM Radio! (see above)&lt;/li&gt;
  &lt;li&gt;Narrow Band FM ( same are FM but a narrower filter passband)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rtl-sdr.com/adsb-aircraft-radar-with-rtl-sdr/&quot;&gt;Listen to and get airplain ADS-B data&lt;/a&gt;
To chekc it out on your own get this software: &lt;a href=&quot;https://github.com/MalcolmRobb/dump1090&quot;&gt;dump1090&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Listen to HAM radio chatter ( usually amplitude modulated )&lt;/li&gt;
  &lt;li&gt;EMS and police and local services radio. &lt;a href=&quot;https://www.radioreference.com/apps/db/&quot;&gt;local scanners and frequencies&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;WeatherFAX. Get latest images of weather data from naval bases! &lt;a href=&quot;http://www.rtl-sdr.com/receiving-weather-rtty-rtl-sdr/&quot;&gt;http://www.rtl-sdr.com/receiving-weather-rtty-rtl-sdr/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Get satellite data (Receive and decode live satellite images of earth):
 These satellite transmit that these frequencies:
NOAA 15 – 137.6200 MHz
NOAA 18 – 137.9125 MHz
NOAA 19 – 137.1000 MHz&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;If transmitted nearby get a newspaper over the radio!&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://theori.io/research/nrsc-5-c&quot;&gt;Decode high definition radio&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Build your own radio astronomy observatory! ( ok we are totally doing that!)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt; ……&lt;a href=&quot;../03&quot;&gt;Next Lab&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 14 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/dspira-lessons/dsplab-sdr/</link>
        <guid isPermaLink="true">http://localhost:4000/dspira-lessons/dsplab-sdr/</guid>
      </item>
    
      <item>
        <title>Digital Signal Processsing using GNURadio - Introductory Lab</title>
        <description>&lt;h1 id=&quot;1-introduction-to-gnu-radio-and-signals&quot;&gt;1. Introduction to GNU Radio and Signals&lt;/h1&gt;

&lt;p&gt;This page shall guide you through our primary tool – GNU Radio. GNU Radio is very popular and robust Software defined radio package. It is open source and is relatively very easy to use. All “coding” is done using flowgraphs comprised of  interconnected Digital Signal Processing (DSP) blocks. Most commonly used blocks come predefined as part of the software package however  one can program their own blocks as well.&lt;/p&gt;

&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-Introduction-to-GNU-Radio-and-Signals&quot;&gt;1. Introduction to GNU Radio and Signals&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#11-Installation-Guide&quot;&gt;1.1. Installation Guide&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#12-GQRX---Its-cool&quot;&gt;1.2. GQRX - It’s cool&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#121-Getting-Started-with-GNU-Radio&quot;&gt;1.2.1. Getting Started with GNU Radio&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#13-Lets-get-Familiar&quot;&gt;1.3. Let’s get Familiar&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#131-A-Cosine-Waveform-generator&quot;&gt;1.3.1. A Cosine Waveform generator&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#132-A-Cosine-Waveform-Generator-with-Variable-Frequency-and-Sound&quot;&gt;1.3.2. A Cosine Waveform Generator with Variable Frequency and Sound&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#133-A-General-Waveform-Generator&quot;&gt;1.3.3. A General Waveform Generator&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#14-GNU-Radio-and-Python&quot;&gt;1.4. GNU Radio and Python&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#141-Arbitrary-Function-generation&quot;&gt;1.4.1. Arbitrary Function generation&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#15-Note-on-the-Frequency-Display&quot;&gt;1.5. Note on the Frequency Display&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#16-Exercises&quot;&gt;1.6. Exercises&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#17-Random-Discrete-Signals&quot;&gt;1.7. Random Discrete Signals&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#18-Sampling&quot;&gt;1.8. Sampling&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#19-Histograms&quot;&gt;1.9. Histograms&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#110-GnuRadio-Companion-Example&quot;&gt;1.10. GnuRadio Companion Example.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#111-Make-your-own-gaussian-noise-block&quot;&gt;1.11. Make your own gaussian noise block&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;

&lt;h2 id=&quot;11-installing-gnuradio&quot;&gt;1.1. Installing GNURadio&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/dspira-lessons/BuildingHorn_SoftwareInfo&quot; class=&quot;button&quot;&gt;Software Info&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;12-gqrx---its-cool&quot;&gt;1.2. GQRX - It’s cool&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://gqrx.dk&quot;&gt;GQRX&lt;/a&gt; is an application written using gnuradio. It acquired data from the dongle and has a set of preset options to manipulate said signals. It can even store raw data for custom decoding. Install gqrx&lt;/p&gt;

&lt;p&gt;First, we make sure our dongle is plugged into the USB see if it is detected by the computer by typing  &lt;code class=&quot;highlighter-rouge&quot;&gt;airspy_info&lt;/code&gt;. If we installed all software correctly it should return information about the dongle and no errors. If everything is in order the type in terminal:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
gqrx
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It will open a window that looks like this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/gqrx2.png&quot; alt=&quot;gqrx&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you are using for the first time the hardware setting window/(IO setting) should open automatically and also automatically detect the dongle.  If not chose &lt;code class=&quot;highlighter-rouge&quot;&gt;AirSpy AIRSPY&lt;/code&gt; from the drop down. 
Otherwise you can open it by clicking on the “circuit board” icon next to the play triangle. The I/O device settings should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/gqrx3.png&quot; alt=&quot;io&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once it is all in order click play. The window should show the spectrum as such:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/gqrx4.png&quot; alt=&quot;spect out&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hit play. Change the frequency to 100 Mhz. Notice the bright bands on the waterfall and the peaks, these are local FM stations&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/gqrx5.png&quot; alt=&quot;io&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Since the sample rate is very high (a feature of this particular hardware). We click on the “circuit board” button again and change input rate 2500000 (from the drop down). In the receiver options the right change &lt;code class=&quot;highlighter-rouge&quot;&gt;Mode&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;WFM&lt;/code&gt; ( wideband FM ) from the drop down and et voila old timey over-the-air radio on your space-age computer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/gqrx6.png&quot; alt=&quot;io&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can use this application to receive even decode to all kinds of signals from 24 – 1800 Mhz. Check out &lt;a href=&quot;../02/#14-fun-sdrgnu-radio-things&quot;&gt;Section 1.4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;121-getting-started-with-gnu-radio&quot;&gt;1.2.1. Getting Started with GNU Radio&lt;/h3&gt;

&lt;p&gt;As mentioned earlier, &lt;em&gt;gqrx&lt;/em&gt; has GNUradio as its engine. We can start developing using this tool right away by typing &lt;code class=&quot;highlighter-rouge&quot;&gt;gnuradio-companion&lt;/code&gt; in the terminal:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/01.png&quot; alt=&quot;start gnuradio-companion&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This opens GNU Radio Companion (GRC):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/02.png&quot; alt=&quot;gnuradio gui&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The “Options” block at the top left is used to set some general parameters of the flowgraph, such as metadata of the flowgraph like the title, author, etc., the graphical user interface (GUI) for widgets and result displays, or the size of the canvas on which the DSP blocks are placed. Right-click on the block and click on Properties (or double-click on the block) to see all the parameters that can be set. Below the Options block is a “Variable” block that is used to set values to variables that are used throughout the flowgraph like the sample rate, e.g.,\(F_s = 32000 Hz\)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/03.png&quot; alt=&quot;top_block&quot; /&gt; &lt;img src=&quot;images/01/img/04.png&quot; alt=&quot;variable block&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Every GRC window has these two very basic blocks. The white space is called the GRC canvas.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;13-lets-get-familiar&quot;&gt;1.3. Let’s get Familiar&lt;/h2&gt;

&lt;p&gt;On the right side of the window is a list of the block categories that are available. Click on a triangle next to a category to see what blocks are available in that category. We will look for the waveform generator category to look for the signal source block. Alternatively, we can click on the magnifying/looking glass to the top right and search for the block we need. We will add the &lt;code class=&quot;highlighter-rouge&quot;&gt;signal source&lt;/code&gt; block to the canvas by double clicking on signal source&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/05.png&quot; alt=&quot;adding signal source&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To move a block on the canvas, grab it with the cursor, press the left mouse button, and move the block to the desired location. You can also rotate blocks by right-clicking on them and then clicking either “Rotate Counterclockwise” or “Rotate Clockwise”. Blocks can also be temporarily disabled by clicking on “Disable”, which is useful for debugging and what-if questions. The rearranged blocks with the options for the “Signal Source” visible are shown next.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Aside&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We notice that the “Signal Source” block has two ports, a grey one on the left and a blue one on the right. The color of a port indicates the type of data generated for an output port or the type of data accepted for an input. The most common data types that we will use are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Blue for complex-valued 32-bit floating point data samples (32 bits for each, real and imaginary part).&lt;/li&gt;
  &lt;li&gt;Orange for real-valued 32-bit floating point data samples&lt;/li&gt;
  &lt;li&gt;Blue-Green for real-valued 32-bit (long) integer data samples&lt;/li&gt;
  &lt;li&gt;Yellow for real-valued 16-bit (short) integer data samples&lt;/li&gt;
  &lt;li&gt;Magenta for real-valued 8-bit (byte) integer data samples&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/06.png&quot; alt=&quot;datatypes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;GNU Radio uses a stream processing model to process large amounts of data in real-time as opposed to a array processing environment (like Matlab). In practice this means that each signal processing block has an independent scheduler running in its own execution thread and each block runs as fast as the CPU, dataflow, and buffer space allows. If there is a hardware source and/or sink that imposes a fixed rate (e.g., 44100 samples/sec for an audio signal, or 10 Msamples/sec for an SDR interface), then that determines the overall processing rate. But if both the source and the sink are implemented purely in software (like a signal generator feeding a time or frequency display), then some form of timing constraint must be imposed in software to limit the processing speed to a specified sampling rate. A special “Throttle” block that we will frequently encounter is used for this purpose. The figure below shows a “Throttle” block connected to the output of the “Signal Source” that we placed earlier. Click on one port follow it by clicking on the other port: this wires the output port of one block to the input port of another block. For the flowgraph to work both ports must use data of the same type (i.e., both ports must be of the same color). If they are of different types, then the arrow of the connection will be red instead of black. It is worth noticing that the word “Throttle” appears in red on the Throttle block, indicating that there is something &lt;em&gt;wrong&lt;/em&gt; with this block in the flowgraph. Things that can go wrong are unspecified or undefined parameters or, as is the case above, connections to/from some ports are missing. If you see any red arrows or red writing in a flowgraph you will not be able to run the flowgraph until the offending condition has been fixed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/07.png&quot; alt=&quot;throttle blocking&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;131-a-cosine-waveform-generator&quot;&gt;1.3.1. A Cosine Waveform generator&lt;/h3&gt;

&lt;p&gt;For our first experiment we want to generate a real-valued cosine signal with frequency 1000 Hz (default for the “Signal Source”) and display it in the time and frequency domains. We start from a flowgraph which consists of a “Signal Source” connected to a “Throttle”. To make the output of the Signal Source real-valued, double-click on the block and in the Properties window that shows up click on “Complex” under “Output Type” and select “Float” as shown below. Then choose “QT” under “Instrumentation” (or just simply search for “QT GUI Sink”) and double-click on “QT GUI Sink”. This block will allow you to see the waveform at the input in the frequency as well as in the time domain. Change the data “Type” from “Complex” to “Float” and connect the input to the output of the “Throttle” block. Save the flowgraph, e.g., as ex01_1.grc&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/08.png&quot; alt=&quot;Example 1 Flowgraph&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now you can run the flowgraph by clicking on the green triangle above the canvas or by clicking “Run” on the menu bar. You can choose between the “Frequency Display” and the “Time Domain Display” tabs as shown below. Use the cursor to zoom in on a rectangular region, increase the FFT size to 4096 or 8192, choose different types of windows, e.g. “rectangular” or “Kaiser” and observe the effects, especially on the Frequency Display. Note that the Frequency Display shows power spectral density (PSD) which is essentially proportional to the magnitude squared of the Fourier transform.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/09.png&quot; alt=&quot;Example 1 Output Frequency&quot; /&gt; &lt;img src=&quot;images/01/img/10.png&quot; alt=&quot;Example 1 Output Frequency&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;132-a-cosine-waveform-generator-with-variable-frequency-and-sound&quot;&gt;1.3.2. A Cosine Waveform Generator with Variable Frequency and Sound&lt;/h3&gt;

&lt;p&gt;We can start from the &lt;code class=&quot;highlighter-rouge&quot;&gt;ex01_1.grc&lt;/code&gt; flowgraph from our first exercise. Under “GUI Widgets” and “QT” select “QT GUI Range”. Double- click on the block so that you get to see its Properties. Change the “ID” from &lt;code class=&quot;highlighter-rouge&quot;&gt;variable_qtgui_range_0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;f0&lt;/code&gt;. For the “Default Value” enter &lt;code class=&quot;highlighter-rouge&quot;&gt;1000&lt;/code&gt;. For the “Start” and the “Stop” values enter &lt;code class=&quot;highlighter-rouge&quot;&gt;-2000&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2000&lt;/code&gt;, respectively. Next we double-click on the “Signal Source” block and change the “Frequency” entry from &lt;code class=&quot;highlighter-rouge&quot;&gt;1000&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;f0&lt;/code&gt;. The respective windows look like below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/12.png&quot; alt=&quot;signal source default freq&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/11.png&quot; alt=&quot;QT Range properties&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To add a sound output, select “Audio” and then double-click on “Audio Sink”. Connect the “Audio Sink” input to the “Throttle” output and leave the “Sample Rate” at the default value of &lt;code class=&quot;highlighter-rouge&quot;&gt;samp_rate (32000 samples/sec)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/13.png&quot; alt=&quot;Audio sink&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Save the flowgraph, e.g., as &lt;code class=&quot;highlighter-rouge&quot;&gt;ex01_2.grc&lt;/code&gt;. If you run the flowgraph now you will get a slider for changing the “Signal Source” frequency from &lt;code class=&quot;highlighter-rouge&quot;&gt;-2000 to +2000 Hz&lt;/code&gt;, you will hear the corresponding sound, and you can choose to display the “Frequency” or the “Time Domain” graph.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/14.png&quot; alt=&quot;GUI out ex01_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Difference between \(+ve\ \&amp;amp;\ -ve\) frequencies?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;133-a-general-waveform-generator&quot;&gt;1.3.3. A General Waveform Generator&lt;/h3&gt;

&lt;p&gt;In this subsection we shall expand upon the previous exercise and learn how to play around with various useful GNU Radio Companion features.  Let us begin by changing &lt;code class=&quot;highlighter-rouge&quot;&gt;ex01_2.grc&lt;/code&gt; flowgraph by removing the “Audio Sink” and the “QT GUI Sink”. Save this new flowgraph as &lt;code class=&quot;highlighter-rouge&quot;&gt;ex01_3.grc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/15.png&quot; alt=&quot;GUI start ex01_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We would like to build a waveform generator that can produce real-valued “Cosine”, “Rectangular”, and “Triangular” waveforms with variable frequency and variable dc offset.  To this end we need “QT GUI Range” blocks and a “QT GUI Chooser (from “GUI Widgets” and “QT”). Connect a “QT GUI Time Sink” and a “QT GUI Frequency Sink” (from “Instrumentation” and “QT”) to the output of the “Throttle” Block. Change the input type of the Sink blocks from “Complex” to “Float”. The flowgraph should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/16.png&quot; alt=&quot;GUI start ex01_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, double-click on the second “QT GUI Range” which will be used to adjust the offset of the waveform and modify the “Properties” as shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/17.png&quot; alt=&quot;Offset&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next, double-click on the “QT GUI Chooser” that will be used to select different waveforms. The (integer) code for “Cosine” is 102, for “Square” it is 103, for “Triangle” it is 104 and for “Sawtooth” it is 105&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/18.png&quot; alt=&quot;Waveform chooser&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, double-click on the “Signal Source” block and modify the “Properties” to look as follows.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/19.png&quot; alt=&quot;Waveform properties&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Double click on the sinks and change to autoscale property to “Yes” respectively. Click the green triangle above the flowgraph or click on “Run” and “Execute” in the GRC menu bar. The output is as below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/20.png&quot; alt=&quot;Output 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The arrangement of graphical elements, such as sliders, choosers, time and frequency sinks, etc., used in a GRC flowgraph can be modified by specifying grid positioning arguments in the “GUI Hint” fields of individual blocks. A grid positioning argument is a list of four integers of the form&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;row, column, row span, column span
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the “GUI Hint” entry is left blank, then the graphical elements are stacked vertically on top of each other. Otherwise, they are placed in the specified &lt;code class=&quot;highlighter-rouge&quot;&gt;row&lt;/code&gt;  and the specified &lt;code class=&quot;highlighter-rouge&quot;&gt;column&lt;/code&gt;, spanning &lt;code class=&quot;highlighter-rouge&quot;&gt;row span&lt;/code&gt; rows and &lt;code class=&quot;highlighter-rouge&quot;&gt;col span&lt;/code&gt; columns. Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;rowspan &amp;gt;= 1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;colspan &amp;gt;= 1&lt;/code&gt; are required.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;(0,0)&lt;/th&gt;
      &lt;th&gt;(0,1)&lt;/th&gt;
      &lt;th&gt;(0,2)&lt;/th&gt;
      &lt;th&gt;(0,3)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;(1,0)&lt;/td&gt;
      &lt;td&gt;(1,1)&lt;/td&gt;
      &lt;td&gt;(1,2)&lt;/td&gt;
      &lt;td&gt;(1,3)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;(2,0)&lt;/td&gt;
      &lt;td&gt;(2,1)&lt;/td&gt;
      &lt;td&gt;(2,2)&lt;/td&gt;
      &lt;td&gt;(2,3)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We shall rearrange our signal generator with the following GUI Hints&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Offset Slider (0,0,1,1)&lt;/th&gt;
      &lt;th&gt;Waveform Selector (0,1,2,1)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Frequency Slider (1,0,1,1)&lt;/td&gt;
      &lt;td&gt;”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Time Display (2,0,1,1)&lt;/td&gt;
      &lt;td&gt;Frequency Display (2,1,1,1)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The GUI hints are updated as seen the following dialog boxes:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/211.png&quot; alt=&quot;GUI Hints&quot; /&gt;
&lt;img src=&quot;images/01/img/212.png&quot; alt=&quot;GUI Hints&quot; /&gt;
&lt;img src=&quot;images/01/img/213.png&quot; alt=&quot;GUI Hints&quot; /&gt;
&lt;img src=&quot;images/01/img/214.png&quot; alt=&quot;GUI Hints&quot; /&gt;
&lt;img src=&quot;images/01/img/215.png&quot; alt=&quot;GUI Hints&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This give the following Output:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/21.png&quot; alt=&quot;Output 1_rearranged&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;14-gnu-radio-and-python&quot;&gt;1.4. GNU Radio and Python&lt;/h2&gt;

&lt;p&gt;GNU Radio is written in python and the final code that does the magic is all in Python. Python is very powerful programing language known for its readability and versatility. The flow graphs created in GNU radio companion are converted into a Python script. All the predefined blocks are written in Python and/or C. One can make their own GNU Radio blocks by coding in Python or C. If you want to know how to do this in depth you can click on this guided tutorial &lt;a href=&quot;https://wiki.gnuradio.org/index.php/Guided_Tutorial_GNU_Radio_in_Python&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;141-arbitrary-function-generation&quot;&gt;1.4.1. Arbitrary Function generation&lt;/h3&gt;

&lt;p&gt;The fact that the end product and much of the guts of GNU Radio is in Python implied we can exploit the standard library of python or our own scripts to test out several things. We shall look into making any arbitrary wave form. This is useful for testing systems designed in gnuradio&lt;/p&gt;

&lt;p&gt;To import a library from python we use the “import” block and we shall employ the “vector source” block to input our arbitrary function. We shall construct a flow graph similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;ex01_3.grc&lt;/code&gt; except we remove the “signal source” and replace with “vector source”, add an “import block” and we shall not worry about the GUI elements for this one. We should have a flowgraph that looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/22.png&quot; alt=&quot;vector source&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We shall import a standard library called &lt;code class=&quot;highlighter-rouge&quot;&gt;numpy&lt;/code&gt;. It allows us to make matrices/vector and manipulate them easily. Double click the import block and fill out the import field as below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/23.png&quot; alt=&quot;numpy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We shall make a rectangular pulse with variable width &lt;code class=&quot;highlighter-rouge&quot;&gt;tau&lt;/code&gt; going from 0 to 10ms, we establish that range using the “QT GUI Range block”&lt;/p&gt;

&lt;p&gt;The function shall be generated shall be generated using the following python code:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tau&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;samp_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tau&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;samp_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Before we place our blocks, we need to add consider a “Tag Object” block &lt;sup id=&quot;fnref:stream&quot;&gt;&lt;a href=&quot;#fn:stream&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. It basically helps us synchronize the sinks when the generated &lt;em&gt;stream tag&lt;/em&gt; associated with our vector source is stopped by the sink. This will alow us to observe the generated pulse. Vector Source has the “Repeat” field which is set to “Yes” so that the pulse of width tau is repeated periodically. Note the “Tag” field. The properties of the blocks are set as below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/24.png&quot; alt=&quot;tau&quot; /&gt;
&lt;img src=&quot;images/01/img/25.png&quot; alt=&quot;tag&quot; /&gt;
&lt;img src=&quot;images/01/img/26.png&quot; alt=&quot;vector&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We set the sinks to have the trigger mode to “tag” and  enter the “Tag Key”  &lt;code class=&quot;highlighter-rouge&quot;&gt;t0&lt;/code&gt; and change the “Number of Points” in the time sink to “samp_rate” and in the frequency sink to “1024 * 6”. This is to properly visualize the signal and its frequency components.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/27.png&quot; alt=&quot;timetrigger&quot; /&gt;
&lt;img src=&quot;images/01/img/28.png&quot; alt=&quot;freqtrigger&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We should then have the flowgraph and output that looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/29.png&quot; alt=&quot;ex01_4&quot; /&gt;
&lt;img src=&quot;images/01/img/30.png&quot; alt=&quot;ex01_4_output&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;15-note-on-the-frequency-display&quot;&gt;1.5. Note on the Frequency Display&lt;/h2&gt;

&lt;p&gt;This particular display may not seem very intuitive for the those seeing it for the first time. It basically shows, as the name suggests, the ‘frequency’ components of the signal. This means the peaks in the graph represents the frequencies of the periodic signals that make up that particular signal. This is the basis of a very important concept called Fourier Analysis. Detailed discussions shall be done in class and systematically demonstrated in &lt;a href=&quot;../03&quot;&gt;Lab 3&lt;/a&gt; and &lt;a href=&quot;../05&quot;&gt;Lab 5&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;16-exercises&quot;&gt;1.6. Exercises&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Delaying Signals:&lt;/em&gt; Use the “delay” block after the signal source and the value of delay can be controlled by a “GUI Range” to make a slider to have the delay change values from 0 to 2000.  See how the the signal changes in a time sink. &lt;strong&gt;NOTE: The delay value indicates the delay in units of number of time samples. Each time sample is&lt;/strong&gt; &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{\verb+samp_rate+} \rm{s}&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GNU Radio has a host of “Math Operators” that will allow you to perform a host of operations:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;images/01/img/31.png&quot; alt=&quot;ex01_4_output&quot; /&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use mulitple signal generators from section &lt;a href=&quot;#123-a-general-waveform-generator&quot;&gt;1.2.3&lt;/a&gt; to add and subtract and multiply to form new waveforms.  We’ll add the examples here!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;17-random-discrete-signals&quot;&gt;1.7. Random Discrete Signals&lt;/h2&gt;

&lt;p&gt;Random signals are signals where the next value can be though of as chips drawn from a hat with many many values, where the exact number of chips with those values relative to each other can be given by an equation, the ‘distribution’.  One of the simplest is a uniform random signal, where each value has an equal number of chips.&lt;/p&gt;

&lt;p&gt;In GnuRadio we can create these signals with a ‘Random Uniform Source’ block.&lt;!-- TOC --&gt;&lt;/p&gt;

&lt;p&gt;A very common distribution in nature is the ‘gaussian’ distribution.&lt;/p&gt;

&lt;h2 id=&quot;18-sampling&quot;&gt;1.8. Sampling&lt;/h2&gt;

&lt;p&gt;Sampling can always be though of as the act of pulling the chips out of the hat, and rounding the value on the chip to the nearest integer. When a real signal is digitized by an analog to digital converter (ADC), every clock cycle, the level of the signal is measured and recorded to the nearest value.&lt;/p&gt;

&lt;h2 id=&quot;19-histograms&quot;&gt;1.9. Histograms&lt;/h2&gt;

&lt;p&gt;A histogram is a plot of the number of occurrences of the signal that occur between a set of levels chosen.  Plotting the histogram is a way of trying to measure the distribution of an incoming random signal.&lt;/p&gt;

&lt;h2 id=&quot;110-gnuradio-companion-example&quot;&gt;1.10. GnuRadio Companion Example.&lt;/h2&gt;

&lt;p&gt;Create the shown GnuRadio flowgraph.&lt;br /&gt;
&lt;img src=&quot;images/01/img/sampling.png&quot; alt=&quot;sampling&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Use a random source between -10 and 10.  The random source only creates discrete integer values, so you also need and Int to Float block with a ‘scale’ which will multiply the incoming signal by the scale value.&lt;/p&gt;

&lt;p&gt;Run the flowgraph, with the scale factor at 1.  What does the time plot look like?  What does the histogram look like?  Now play with the scale factor.  Can the histogram have large gaps? Can you make the histogram look continuous?  What intuition do you gain from this about sampling a ‘random’ signal?&lt;/p&gt;

&lt;p&gt;Now also try different distribution sources.  Use the “Noise Source” block and set it to a gaussian distribution.  What does the time stream look like?  What about the histogram?&lt;/p&gt;

&lt;p&gt;Now again use a cosine input signal as you’ve used in a previous exercise.  What does the time series look like?  The histogram?  A cosine signal is not very random.  What if instead, each measured point in time of the cosine was completely randomized (could also think of using a uniform random signal put through a cosine function)?  Would the histogram look any different?  This would also be a random signal, and has the functional form &lt;script type=&quot;math/tex&quot;&gt;\frac{A}{\sqrt{1-y^2}}&lt;/script&gt;, which should agree with your histogram.&lt;/p&gt;

&lt;h2 id=&quot;111-make-your-own-gaussian-noise-block&quot;&gt;1.11. Make your own gaussian noise block&lt;/h2&gt;

&lt;p&gt;You are now ready to try to make your own gaussian noise block out of other blocks.&lt;/p&gt;

&lt;p&gt;Create a new flowgraph in grc.
 We’ll start by using a just a QLFSR block.  This is a ‘linear feedback shift register’  block, which is a very simple way to create ‘pseudorandom’ noise.  Look &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;here&lt;/a&gt; for more details.  Set the type to float, the degree (how many elements in the shift register) to 32, repeat yes.  Change the seed to any number.  Leave the ‘mask’ at zero to get an ‘optimal’ source that wont repeat.  Try using other numbers to compare, 1075838979 is a nice choice for random looking data.  Use a histogram sink and a gui sink to look at the output.  Even though the output is only -1 or 1, without knowing the initial seed and how many cycles have gone by, the answer is random.&lt;/p&gt;

&lt;p&gt;Add a number of these sources together:
 &lt;img src=&quot;images/01/img/lfsr_noise.png&quot; alt=&quot;gaussian&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What does the output look like now?  This is one of the simple ways of going from a ‘flat’ random number to a gaussian white noise.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;↑ Go to the Top of the Page&lt;/a&gt; ……&lt;a href=&quot;../02&quot;&gt;Next Lab&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Extra Materials:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.gnuradio.org/index.php/Guided_Tutorial_GRC&quot;&gt;A guided tutorial by gnuradio&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;this tutorial has been adapted from this &lt;a href=&quot;http://ecee.colorado.edu/~mathys/ecen4652/labs.html&quot;&gt;lab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:stream&quot;&gt;
      &lt;p&gt;For a technical explaination of the block &lt;a href=&quot;https://gnuradio.org/doc/doxygen/page_stream_tags.html&quot;&gt;click here&lt;/a&gt; &lt;a href=&quot;#fnref:stream&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 14 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/dspira-lessons/dsplab-intro/</link>
        <guid isPermaLink="true">http://localhost:4000/dspira-lessons/dsplab-intro/</guid>
      </item>
    
      <item>
        <title>Digital Signal Processsing</title>
        <description>&lt;h1 id=&quot;dsp-lectures&quot;&gt;DSP Lectures&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Lectures&lt;/th&gt;
      &lt;th&gt;Demonstrations&lt;/th&gt;
      &lt;th&gt;Laboratory Exercises&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/4ff26b2d1e334c199f9644f7c21f4f8d1d&quot;&gt;Introduction to Signals&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;1. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/3a1842a284284aa5b08b533e3af825b71d&quot;&gt;Sampling&lt;/a&gt; &lt;br /&gt;2. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/040268aefe154838a6b16d5890a526331d&quot;&gt;Mixing&lt;/a&gt; &lt;br /&gt;3. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/ac80f7e2da8a4bf5856d7a1fa61053361d&quot;&gt;Mixing (Frequency)&lt;/a&gt; &lt;br /&gt; 4. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/8de0d7fd64784c239f6b94b14161218e1d&quot;&gt;Histograms&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;1. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/1150c64dea0e41e5823ad63496e629d71d&quot;&gt;Installing GNU Radio&lt;/a&gt; &lt;br /&gt; 2. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/b3ab05640dee404bb30f9b84f2d25afd1d&quot;&gt;Getting Started with GNU Radio&lt;/a&gt; &lt;br /&gt; 3. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/4d9cf034b5d1473b9467f69a15e1fcd31d&quot;&gt;Making your first GNU Radio program&lt;/a&gt; &lt;br /&gt; 4. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/3d2c6810d9b847c19b087c23e521f26b1d&quot;&gt;Best GNURadio Practices&lt;/a&gt; &lt;br /&gt; 5. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/622949d398ef4d55be1e6ea19845b3071d&quot;&gt; Beautify your GNURadio GUI&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/bf73dba28e29455f9a966ce64f94042a1d&quot;&gt;Periodic and Non-Periodic Signals Fourier Series&lt;/a&gt;  &lt;br /&gt; 2. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/d9adb334770a49e089a77f7b0a70dea31d&quot;&gt;Fourier Series&lt;/a&gt;	&lt;br /&gt; 3. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/1d689eed4e1740d4b48dd7cc902e33281d&quot;&gt;Frequency Content of Non-Periodic Signals&lt;/a&gt; &lt;br /&gt; 4. &lt;a href=&quot;https://youtu.be/r6sGWTCMz2k&quot;&gt;Fourier Analysis - External Youtube Video&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;1. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/2407d3c94138460894e4357070b576281d&quot;&gt;Fourier Analysis in GNU Radio&lt;/a&gt; &lt;br /&gt; 2. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/057d930e6e1a4bb2ac80c6752b748e751d&quot;&gt;Fourier Analysis - another Demo&lt;/a&gt; &lt;br /&gt; 3. &lt;a href=&quot;http://www.jezzamon.com/fourier/&quot;&gt;A Fourier Transforms Explainer - external website&lt;/a&gt; &lt;br /&gt; 4. &lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/b85fac1246f4498da147cbc12fc5e0181d&quot;&gt;Real Signals&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/d2ae73260b124113aecdce7c63755c451d&quot;&gt;The FFT Block&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/6aea73645b554d3099a5e32831d445a01d&quot;&gt;Filters&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://mediasitecs.lib.wvu.edu/Mediasite1/Play/761f9a7aecd14a949ae7a67224345fe41d&quot;&gt;Filters GNURadio Demo&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Fri, 14 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/dspira-lessons/dsp</link>
        <guid isPermaLink="true">http://localhost:4000/dspira-lessons/dsp</guid>
      </item>
    
      <item>
        <title>Computer and Software Needs for the Horn Telescope Spectrometer</title>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Installation of any of the following software options will allow the user to run the spectrometer program to operate a horn telescope that is equipped with an LNA, software defined radio (Airspy or equivalent), and the proper cables. See the document &lt;a href=&quot;https://wvurail.org/dspira-lessons/BuildingHornTelescope_Overview&quot;&gt;What is Needed to Build a Horn Telescope&lt;/a&gt; and links therein for more details about the telescope system.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Different options for operating the horn telescope spectrometer program, &lt;em&gt;spectrometer_w_cal.grc&lt;/em&gt;, are presented here. The options provided vary depending on the user’s computer system and his or her comfort level working with computers.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The options presented below include a brief description of the system requirements and what is involved in the installation process.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://wvurail.org/dspira-lessons/Install_Ubuntu_spectrometer_onFlashdrive&quot;&gt;Download a fully operating image onto a flash drive that can be operated from most computer systems.&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Easiest for those who are the less experienced in working with computer system software.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Requires a computer and a 32 GB, 3.0 USB flash drive.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Once the flash drive image is created, the spectrometer program can be run on the following systems:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;pc with Windows: minimum system specs?, brand names?&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;MAC with OS ?? or higher&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Linux system, such as one running Ubuntu 20.04.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;The software needed is to complete the installation is free and easy to install.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Click &lt;a href=&quot;https://wvurail.org/dspira-lessons/Install_Ubuntu_spectrometer_onFlashdrive&quot;&gt;here&lt;/a&gt; for installation instructions.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://wvurail.org/dspira-lessons/BuildingHorn_SoftwareInfo&quot;&gt;Install the free &amp;amp; open-source software, &lt;em&gt;GnuRadio&lt;/em&gt;, on a Linux system operating Ubuntu 20.04.&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;This option is for those who are more experienced with computers and feel comfortable installing software on a hard drive.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Requires a computer that either already runs on the Ubuntu operating system, or has a hard drive running Windows that can be partitioned.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;It may require partitioning a hard drive in Windows and installing Ubuntu 20.04 on it, if the system is not already running Ubuntu.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Once Ubuntu is installed, further installations include installing the free &amp;amp; open-source software &lt;em&gt;GnuRadio&lt;/em&gt;, and then installing the spectrometer program from Github.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;After installation, the computer will be able to run the telescope system directly.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Click &lt;a href=&quot;https://wvurail.org/dspira-lessons/BuildingHorn_SoftwareInfo&quot;&gt;here&lt;/a&gt; for installation instructions.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Install the spectrometer program on a Raspberry Pi.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;This can be done, but the details have not been fully worked out by us (the DSPIRA group).&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Details to follow.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 14 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/dspira-lessons/HornOperation_computerSystems</link>
        <guid isPermaLink="true">http://localhost:4000/dspira-lessons/HornOperation_computerSystems</guid>
      </item>
    
      <item>
        <title>Detailed LNA Construction Instructions</title>
        <description>&lt;h2 id=&quot;overview-of-constructing-the-lna&quot;&gt;Overview of Constructing the LNA&lt;/h2&gt;

&lt;p&gt;The construction of the LNA is complicated and you may wonder how and where to start.&lt;/p&gt;
&lt;h3 id=&quot;first-assemble-a-soldering-station&quot;&gt;First: Assemble a Soldering Station&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Get a soldering iron and a hot air gun that have temperature controls. The cheap hobby soldering iron will not do. You should set the operating temperature of the soldering iron and hot air gun to 350°C.&lt;/li&gt;
  &lt;li&gt;Get a soldering stand. It should consist of a magnifying glass, a light, moveable helping hands, a cleaning sponge, fine tip twezzers, and a cleaning mesh.&lt;/li&gt;
  &lt;li&gt;Get a spool of solder. Most solders are a mixture of tin and lead. There are also solders made up of tin and silver, but they melt at a higher temperature and are much harder to use. Solder also comes in different thicknesses or diameters. A thickness of 0.025 inches is a good size for the soldering you’ll be doing.&lt;/li&gt;
  &lt;li&gt;The following is a picture of a typical soldering station. It is also called a rework station. The setup shown was purchased from Amazon for about $100. You can also go online and search for soldering irons, hot air guns, rework stations, and soldering stations.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/dspira-lessons/images/SolderingStation.JPG&quot; alt=&quot;A Typical Soldering Station&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;second-order-and-purchase-the-components-of-the-lna&quot;&gt;Second: Order and Purchase the Components of the LNA&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Click on the &lt;em&gt;&lt;a href=&quot;https://drive.google.com/file/d/1aHKy0YQeys0RdvzMzBeTztgR0km7af_V/view?usp=sharing&quot;&gt;LNA Ordering Parts Info&lt;/a&gt;&lt;/em&gt; link for the list of components and where the components can be purchased.&lt;/li&gt;
  &lt;li&gt;Order a bottle of silicone conformal coating. Although this is not a component of the LNA, you will need to coat your circuit board after you are done soldering everything on. This coating will protect your LNA from moisture, corrosion, fungus, dirt, dust, thermal shock, short circuits, and static discharge. This product is available through Amazon. You can also do a Google search for silicone conformal coating to find other sellers.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;third-solder-the-components-onto-the-circuit-board&quot;&gt;Third: Solder the Components onto the Circuit Board&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;There is no best order for soldering the components onto the circuit board. If you are new to soldering, soldering all the  components of one type before soldering all the components of another type is a good approach. The following order of soldering is typical for a person new to soldering: capacitors, resistors, inductors, transistors, ICs, SMA connectors, and the cover. Capacitors and resistors are the easiest components to solder onto the circuit board and will give the novice a chance to learn the proper techniques for successful soldering.&lt;/li&gt;
  &lt;li&gt;If you have some soldering experience, I would suggest soldering the hardest components first: transistors, ICs, inductors, resistors, capacitors, SMA connectors, and the cover.&lt;/li&gt;
  &lt;li&gt;The following is a link to a &lt;em&gt;&lt;a href=&quot;https://drive.google.com/file/d/1PwT-tn9KpN2fMcUG9MIAAlKz2KKEgYRl/view?usp=sharing&quot;&gt;Circuit Diagram of the LNA and an Image of the Circuit Board&lt;/a&gt;&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;detailed-soldering-instructions-for-each-component&quot;&gt;Detailed Soldering Instructions for Each Component&lt;/h2&gt;

&lt;h3 id=&quot;soldering-a-capacitor&quot;&gt;Soldering a Capacitor&lt;/h3&gt;

&lt;p&gt;Place the tip of the soldering iron onto one of the pads and melt a small drop of solder onto the pad. The drop should barely fill the pad. Place one end of the capacitor onto the drop of solder. Touch both the end of the capacitor and drop of solder with the tip of the soldering iron and the heat should melt the solder and the solder should pull the capacitor to the pad. This should make a good connection between the capacitor and pad. Solder the other end of the capacitor to the other pad by touching the tip of the soldering iron to both the pad and the end of the capacitor. Touch the solder to the end of the capacitor and soldering iron. A drop of solder should melt and adhere to the pad and the end of the capacitor. Click on the video link for a demonstration of soldering a capacitor.&lt;/p&gt;

&lt;p&gt;https://youtu.be/sOWDIGIjmGE&lt;/p&gt;

&lt;h3 id=&quot;soldering-a-resistor&quot;&gt;Soldering a Resistor&lt;/h3&gt;

&lt;p&gt;Soldering a resistor is identical to soldering a capacitor. You may encounter difficulty in getting solder to melt on the pad. That is because the pad you chose is part of the ground and the ground is the copper that goes all around the circuit board. So you’re heating up a large portion of the circuit board before the pad you’re interested in comes up to the correct temperature. Click on the video link for a demonstration of soldering a resistor.&lt;/p&gt;

&lt;p&gt;https://youtu.be/EFwzL3n3f7s&lt;/p&gt;

&lt;h3 id=&quot;soldering-an-inductor&quot;&gt;Soldering an Inductor&lt;/h3&gt;

&lt;p&gt;Soldering an inductor starts the same way as a resistor, a capacitor, or any component to be soldered onto the circuit board: a small drop of solder melted onto a pad. The tricky part of soldering an inductor is that the metal plate is on the bottom of the inductor and not on the side like a resistor or a capacitor. It is important to have the tip of the soldering iron touching the bottom plate of the inductor. It is also important to leave as much room as possible on the other pad. The pad will be soldered to the thin side of the bottom plate of the inductor. Click on the video link for a demonstration of soldering an inductor.&lt;/p&gt;

&lt;p&gt;https://youtu.be/9CNtz4u5we0&lt;/p&gt;

&lt;h3 id=&quot;soldering-a-transistor&quot;&gt;Soldering a Transistor&lt;/h3&gt;

&lt;p&gt;There are three different types of transistors to be soldered onto the circuit board. Each one has its own difficulties in soldering onto the circuit board. You sould watch each of the following videos before soldering to determine the orientation of each transistor.&lt;/p&gt;

&lt;h4 id=&quot;transistors-u1--u3&quot;&gt;Transistors U1 &amp;amp; U3&lt;/h4&gt;

&lt;p&gt;https://youtu.be/DP3ABBXyuwY&lt;/p&gt;

&lt;h4 id=&quot;transistor-u2&quot;&gt;Transistor U2&lt;/h4&gt;

&lt;p&gt;https://youtu.be/kvlXMtPB2FY&lt;/p&gt;

&lt;h4 id=&quot;transistors-u4--u5&quot;&gt;Transistors U4 &amp;amp; U5&lt;/h4&gt;

&lt;p&gt;https://youtu.be/xhfXKow-tOs&lt;/p&gt;

&lt;h3 id=&quot;soldering-an-integrated-circuit-ic&quot;&gt;Soldering an Integrated Circuit (IC)&lt;/h3&gt;

&lt;p&gt;Soldering an IC is similar to soldering transistors U1 and U3. Click on the video link for a demonstration of soldering an IC.&lt;/p&gt;

&lt;p&gt;https://youtu.be/Vwu3AeRIN9w&lt;/p&gt;

&lt;h3 id=&quot;soldering-the-sma-connectors&quot;&gt;Soldering the SMA Connectors&lt;/h3&gt;

&lt;p&gt;There are two SMA connectors on the circuit board: X1 and X2. One SMA connects the antenna feed to the LNA (X1) and the other SMA is the output of the LNA to the AirSpy (X2). Click on the video link for a demonstration of soldering an SMA connector.&lt;/p&gt;

&lt;p&gt;https://youtu.be/3jxUv_rlqTI&lt;/p&gt;

&lt;h3 id=&quot;soldering-on-the-protective-cover&quot;&gt;Soldering on the Protective Cover&lt;/h3&gt;

&lt;p&gt;The protective cover should not be soldered on until after the LNA is tested and is determined to function properly. Once the protective cover is soldered on, it will be difficult to make any repairs. The protective cover is also hard to remove after it has been soldered on. Click on the video link for a demonstration of soldering on the protective cover.&lt;/p&gt;

&lt;p&gt;Video link to be determined&lt;/p&gt;

&lt;h3 id=&quot;applying-the-protective-coating&quot;&gt;Applying the Protective Coating&lt;/h3&gt;

&lt;p&gt;Applying the silicone conformal coating is the last step for constructing the LNA. Click on the video link for a demonstration of how to cover the LNA with the silicone conformal coating.&lt;/p&gt;

&lt;p&gt;Video link to be determined&lt;/p&gt;
</description>
        <pubDate>Fri, 14 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/dspira-lessons/DetailedLNAInstructions</link>
        <guid isPermaLink="true">http://localhost:4000/dspira-lessons/DetailedLNAInstructions</guid>
      </item>
    
      <item>
        <title>How to Install Ubuntu 20.04 with spectrometer_w_cal.grc on Bootable Flashdrive</title>
        <description>&lt;h4 id=&quot;how-to-install-ubuntu2004gnuradio38spectrometer_w_calgrc-on-a-bootable-flashdrive&quot;&gt;How to Install Ubuntu20.04/Gnuradio3.8/spectrometer_w_cal.grc on a Bootable Flashdrive&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Before starting, you will need the program &lt;em&gt;balenaEtcher&lt;/em&gt;, which is an easy-to-use cross-platform tool for burning images to SD cards, USB drives and other removable devices. It can be downloaded from https://www.balena.io/etcher/.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Download the file &lt;a href=&quot;https://drive.google.com/file/d/1coOjDiu2bStTXmbzjN3DtGWiOAAG5scW/view?usp=sharing&quot;&gt;ubuntu_radio_astro20202.iso.zip&lt;/a&gt; while in either Windows or Ubuntu.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unzip this file in a folder of your choice to create the file &lt;em&gt;ubuntu_radio_astro20202.iso&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Install a 32 GB or larger flash drive in the usb port. [We recommend a Samsung 32 GB flash drive.]&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Run &lt;em&gt;balenaEtcher&lt;/em&gt;. Choose the file &lt;em&gt;ubuntu_radio_astro20202.iso&lt;/em&gt; as the image and the flash drive as the target.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;strong&gt;Ubuntu with spectrometer_w_cal.grc&lt;/strong&gt; image should now be on this bootable flashdrive.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;how-to-run-gnuradio-and-the-spectrometer_w_calgrc-program-from-the-flashdrive&quot;&gt;How to Run Gnuradio and the spectrometer_w_cal.grc program from the flashdrive.&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;To run Gnuradio and the &lt;em&gt;spectrometer_w_cal.grc&lt;/em&gt; program, place the bootable flash drive in a USB port.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Start or reboot the computer. While it is starting, hold down the bootable key (F12) to pull up a menu of boot options.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scroll down to the flashdrive and hit enter.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On the first installation screen, choose &lt;strong&gt;run Ubuntu persistent live&lt;/strong&gt; (the choice at the top). IT MAY TAKE A FEW MINUTES FOR THE SYSTEM TO BOOT UP, DEPENDING ON THE FLASHDRIVE USED. BE PATIENT!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Open a Terminal by selecting the terminal icon on the left menu bar.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Type and enter &lt;code class=&quot;highlighter-rouge&quot;&gt;gnuradio-companion&lt;/code&gt; at the prompt.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;em&gt;spectrometer_w_cal.grc&lt;/em&gt; program should open.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NOTE: When the save/write to file buttons are hit, the data files are written to the Spectra folder.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NOTE: The system clock time defaults to UTC/London. Change it if needed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Enjoy radio astronomy observations!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 07 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/dspira-lessons/Install_Ubuntu_spectrometer_onFlashdrive</link>
        <guid isPermaLink="true">http://localhost:4000/dspira-lessons/Install_Ubuntu_spectrometer_onFlashdrive</guid>
      </item>
    
  </channel>
</rss>
